<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Video Interview - Professional Practice Platform</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #4f46e5;
            --primary-light: #6366f1;
            --secondary: #6b7280;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --bg-primary: #030712;
            --bg-secondary: #111827;
            --bg-tertiary: #1f2937;
            --text-primary: #f9fafb;
            --text-secondary: #d1d5db;
            --text-muted: #9ca3af;
            --border: #374151;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
            --border-radius: 0.75rem;
            --transition: all 0.2s ease-in-out;
        }

        .hidden {
            display: none !important;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background-color: var(--bg-primary);
            background-image: radial-gradient(ellipse 80% 50% at 50% -20%, rgba(120, 119, 198, 0.3), transparent);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .setup-container {
            min-height: 100vh;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            position: relative;
            border-radius: 24px;
        }

        .subtitles-overlay {
            position: absolute;
            left: 50%;
            bottom: 76px;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, .65);
            color: #fff;
            padding: .6rem .9rem;
            border-radius: 10px;
            font-size: 1rem;
            line-height: 1.35;
            max-width: 88%;
            text-align: center;
            z-index: 20;
            pointer-events: none;
            white-space: pre-wrap;
        }


        .setup-container::before {
            display: none;
        }

        .setup-card {
            background: rgba(17, 24, 39, 0.6);
            backdrop-filter: blur(24px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 24px;
            padding: 2rem 3rem;
            max-width: 900px;
            width: 100%;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            position: relative;
            z-index: 2;
        }

        .setup-header {
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .setup-logo {
            width: 56px;
            height: 56px;
            background: linear-gradient(135deg, var(--primary), var(--primary-light));
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 1.5rem;
            box-shadow: 0 0 20px rgba(79, 70, 229, 0.4);
        }

        .setup-title {
            font-size: 2.25rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--text-primary), var(--text-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.75rem;
        }

        .setup-subtitle {
            color: var(--text-muted);
            font-size: 1.1rem;
            line-height: 1.6;
            max-width: 450px;
            margin: 0 auto;
        }

        .form-grid {
            display: grid;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-label {
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .form-input,
        .form-select {
            padding: 0.875rem 1rem;
            background: rgba(17, 24, 39, 0.8);
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            color: var(--text-primary);
            font-size: 1rem;
            transition: var(--transition);
        }

        .select-wrapper {
            position: relative;
            display: block;
        }

        /* Custom Dropdown Styles */
        .custom-dropdown {
            position: relative;
            width: 100%;
        }

        .custom-dropdown-trigger {
            padding: 0.875rem 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            color: var(--text-primary);
            font-size: 1rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: var(--transition);
            width: 100%;
        }

        .custom-dropdown-trigger:hover {
            background-color: #0b1220;
            border-color: var(--primary-light);
        }

        .custom-dropdown.open .custom-dropdown-trigger {
            border-color: var(--primary-light);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
        }

        .custom-dropdown-arrow {
            transition: transform 0.2s ease;
        }

        .custom-dropdown.open .custom-dropdown-arrow {
            transform: rotate(180deg);
        }

        .custom-dropdown-menu {
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            right: 0;
            background: #0b1220;
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            max-height: 280px;
            overflow-y: auto;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.2s ease;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        }

        .custom-dropdown.open .custom-dropdown-menu {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .custom-dropdown-group-label {
            padding: 0.5rem 1rem;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            background: rgba(255, 255, 255, 0.03);
        }

        .custom-dropdown-option {
            padding: 0.75rem 1rem;
            color: var(--text-primary);
            cursor: pointer;
            transition: background 0.15s ease;
            font-size: 0.95rem;
        }

        .custom-dropdown-option:hover {
            background: rgba(99, 102, 241, 0.15);
        }

        .custom-dropdown-option.selected {
            background: var(--primary);
            color: white;
        }

        .custom-dropdown-menu::-webkit-scrollbar {
            width: 8px;
        }

        .custom-dropdown-menu::-webkit-scrollbar-track {
            background: #0b1220;
        }

        .custom-dropdown-menu::-webkit-scrollbar-thumb {
            background-color: #334155;
            border-radius: 4px;
        }

        .form-select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            color-scheme: dark;
            width: 100%;
            line-height: 1.2;
            cursor: pointer;

            background-color: var(--bg-secondary);
            color: var(--text-primary);
            border-color: var(--border);
        }

        .form-select:hover {
            background-color: #0b1220;
        }

        .form-select:focus {
            outline: none;
            border-color: var(--primary-light);
            background-color: #0b1220;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25);
        }


        .form-select option,
        .form-select optgroup {
            background-color: #0b1220 !important;
            color: #f9fafb !important;
            padding: 0.75rem 1rem;
            font-size: 0.95rem;
            border-radius: 0;
        }

        .form-select option:checked,
        .form-select option:focus,
        .form-select option:hover {
            background-color: var(--primary) !important;
            color: #ffffff !important;
        }


        @media (-ms-high-contrast: active) {
            .form-select {
                border: 2px solid windowText;
            }
        }


        .form-select::-webkit-scrollbar {
            width: 12px;
        }

        .form-select::-webkit-scrollbar-track {
            background: #0b1220;
        }

        .form-select::-webkit-scrollbar-thumb {
            background-color: #334155;
            border-radius: 8px;
            border: 3px solid #0b1220;
        }


        @-moz-document url-prefix() {

            .form-select,
            .form-select option,
            .form-select optgroup {
                background-color: #0b1220 !important;
                color: #f9fafb !important;
            }
        }

        .form-input:focus,
        .form-select:focus {
            outline: none;
            border-color: var(--primary-light);
            background: var(--bg-secondary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
        }

        .btn {
            padding: 1rem 2rem;
            border: none;
            border-radius: var(--border-radius);
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            position: relative;
            overflow: hidden;
        }

        .btn-primary {
            background-image: linear-gradient(to right, #4f46e5 0%, #7c3aed 50%, #4f46e5 100%);
            background-size: 200% auto;
            color: white;
            box-shadow: 0 4px 15px 0 rgba(79, 70, 229, 0.35);
        }

        .btn-primary:hover {
            background-position: right center;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(79, 70, 229, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }


        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 3px solid rgba(59, 130, 246, 0.2);
            border-top: 3px solid var(--primary-light);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 1.5rem;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            color: var(--text-secondary);
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
        }

        .loading-progress {
            width: 200px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--primary-light));
            width: 0%;
            transition: width 0.5s ease;
        }


        .interview-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
        }

        .interview-header {
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--border);
            z-index: 10;
        }

        .interview-title {
            font-weight: 600;
            color: var(--text-primary);
        }

        .interview-controls {
            display: flex;
            gap: 1rem;
            margin-left: auto;
        }

        .control-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .control-btn.active {
            background: var(--primary-light);
        }

        .control-btn.danger {
            background: var(--error);
        }

        .interview-main {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 340px;
            gap: 1rem;
            padding: 1rem;
            overflow: hidden;
            padding-bottom: 96px;
        }

        .main-video {
            background: var(--bg-secondary);
            border-radius: var(--border-radius);
            position: relative;
            overflow: hidden;
            min-height: 400px;
            border: 1px solid var(--border);
        }

        .avatar-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .video-overlay {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            right: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            pointer-events: none;
        }

        .participant-info {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            color: white;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .video-status {
            display: flex;
            gap: 0.5rem;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success);
            box-shadow: 0 0 8px var(--success);
        }

        .status-indicator.muted {
            background: var(--error);
            box-shadow: 0 0 8px var(--error);
        }

        .sidebar {
            width: 340px;
            background: var(--bg-secondary);
            border-radius: var(--border-radius);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid var(--border);
        }

        .user-video {
            height: 180px;
            background: var(--bg-tertiary);
            position: relative;
            border-radius: var(--border-radius) var(--border-radius) 0 0;
            border-bottom: 1px solid var(--border);
        }

        .user-video video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .chat-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 1rem;
            overflow: hidden;
            min-height: 0;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 1rem;
            max-height: 100%;
            scrollbar-width: thin;
        }

        .message {
            margin-bottom: 1rem;
            max-width: 90%;
        }

        .message.ai {
            align-self: flex-start;
        }

        .message.user {
            align-self: flex-end;
        }

        .message-author {
            font-weight: 600;
            font-size: 0.85rem;
            margin-bottom: 0.35rem;
            color: var(--text-secondary);
        }

        .message-content {
            padding: 0.75rem 1rem;
            border-radius: 12px;
            line-height: 1.5;
            color: var(--text-primary);
        }

        .message.ai .message-content {
            background: var(--bg-tertiary);
            border-top-left-radius: 2px;
        }

        .message.user .message-content {
            background: var(--primary);
            color: white;
            border-top-right-radius: 2px;
        }

        .chat-input-container {
            display: flex;
            gap: 0.5rem;
        }

        .chat-input {
            flex: 1;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 8px;
            color: var(--text-primary);
            resize: none;
            min-height: 40px;
            max-height: 100px;
        }

        .send-btn {
            width: 40px;
            height: 40px;
            background: var(--primary-light);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
        }

        .send-btn:hover {
            background: var(--primary);
        }


        .push-to-talk-container {
            position: relative;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .push-to-talk-btn {
            width: 56px;
            height: 56px;
            border: 3px solid var(--primary-light);
            border-radius: 50%;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
            font-size: 1.3rem;
            position: relative;
        }

        .push-to-talk-btn:hover {
            background: rgba(59, 130, 246, 0.1);
            border-color: var(--primary);
        }

        .push-to-talk-btn.recording {
            background: var(--error);
            border-color: var(--error);
            color: white;
            animation: pulse-recording 1.5s infinite;
        }

        @keyframes pulse-recording {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        .push-to-talk-hint {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-left: 0.5rem;
        }


        .speech-status {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-size: 0.8rem;
            white-space: nowrap;
            margin-bottom: 0.5rem;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .speech-status.visible {
            opacity: 1;
        }


        .interview-footer {
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            border-top: 1px solid var(--border);
        }

        .footer-controls {
            display: flex;
            gap: 1rem;
        }

        .footer-btn {
            width: 48px;
            height: 48px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
            font-size: 1.2rem;
        }

        .footer-btn.mic {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .footer-btn.mic.muted {
            background: var(--error);
            color: white;
        }

        .footer-btn.camera {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .footer-btn.camera.off {
            background: var(--error);
            color: white;
        }

        .footer-btn.end-call {
            background: var(--error);
            color: white;
        }

        .footer-btn.subtitles {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .footer-btn.subtitles.active {
            background: var(--primary-light);
            color: white;
        }


        /* Large Screens (1400px+) */
        @media (min-width: 1400px) {
            .setup-card {
                max-width: 1000px;
                padding: 2.5rem 4rem;
            }

            .setup-title {
                font-size: 2.5rem;
            }

            .form-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 1.25rem;
            }

            .form-group:first-child {
                grid-column: span 2;
            }

            .btn-primary {
                grid-column: span 2;
            }
        }

        /* Desktop (1024px - 1400px) */
        @media (min-width: 1024px) and (max-width: 1399px) {
            .setup-card {
                max-width: 900px;
            }

            .form-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 1rem;
            }

            .form-group:first-child {
                grid-column: span 2;
            }

            .btn-primary {
                grid-column: span 2;
            }
        }

        /* Tablets (768px - 1023px) */
        @media (min-width: 768px) and (max-width: 1023px) {
            .setup-container {
                padding: 1rem;
            }

            .setup-card {
                max-width: 700px;
                padding: 2rem;
            }

            .setup-title {
                font-size: 2rem;
            }

            .form-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 1rem;
            }

            .form-group:first-child {
                grid-column: span 2;
            }

            .btn-primary {
                grid-column: span 2;
            }
        }

        /* Mobile (max-width: 767px) */
        @media (max-width: 767px) {
            .setup-container {
                padding: 0.5rem;
                min-height: 100vh;
                height: auto;
            }

            .setup-card {
                padding: 1.5rem;
                border-radius: 16px;
                max-height: none;
            }

            .setup-title {
                font-size: 1.75rem;
            }

            .setup-subtitle {
                font-size: 0.95rem;
            }

            .setup-header {
                margin-bottom: 1rem;
            }

            .setup-logo {
                width: 48px;
                height: 48px;
                margin-bottom: 1rem;
            }

            .form-grid {
                grid-template-columns: 1fr;
                gap: 0.75rem;
                margin-top: 1rem;
            }

            .custom-dropdown-trigger {
                padding: 0.75rem 1rem;
                font-size: 0.95rem;
            }

            .custom-dropdown-menu {
                max-height: 220px;
            }

            .btn {
                padding: 0.875rem 1.5rem;
                font-size: 0.95rem;
            }

            .interview-main {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto;
                padding-bottom: 108px;
            }

            .main-video {
                min-height: 260px;
                height: 55vh;
            }

            .sidebar {
                width: 100%;
                height: auto;
                max-height: calc(45vh - 8px);
                display: grid;
                grid-template-columns: 180px 1fr;
            }

            .user-video {
                width: 200px;
                height: 100%;
                border-radius: var(--border-radius) 0 0 var(--border-radius);
                flex-shrink: 0;
            }

            .chat-section {
                min-height: 140px;
                overflow: hidden;
            }

            .chat-messages {
                max-height: calc(45vh - 60px);
                overflow-y: auto;
            }

            .subtitles-overlay {
                bottom: 96px;
                font-size: 0.9rem;
                max-width: 92%;
            }
        }

        /* Small Mobile (max-width: 480px) */
        @media (max-width: 480px) {
            .setup-container {
                padding: 0.25rem;
            }

            .setup-card {
                padding: 1.25rem;
                border-radius: 12px;
            }

            .setup-title {
                font-size: 1.5rem;
            }

            .setup-subtitle {
                font-size: 0.9rem;
            }

            .setup-logo {
                width: 44px;
                height: 44px;
            }

            .form-label {
                font-size: 0.85rem;
            }

            .custom-dropdown-trigger {
                padding: 0.7rem 0.875rem;
                font-size: 0.9rem;
            }

            .sidebar {
                grid-template-columns: 140px 1fr;
            }

            .main-video {
                min-height: 240px;
                height: 52vh;
            }
        }


        .floating-ptt {
            position: fixed;
            right: 16px;
            bottom: 88px;
            z-index: 1100;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            pointer-events: none;
        }

        .floating-ptt .push-to-talk-container {
            pointer-events: auto;
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 8px 10px;
            border-radius: 14px;
            backdrop-filter: blur(8px);
        }

        @media (max-width: 768px) {
            .floating-ptt {
                bottom: 96px;
                right: 12px;
            }
        }

        /* hide self camera on mobile and simplify sidebar layout */
        @media (max-width: 768px) {
            .user-video {
                display: none;
            }

            .sidebar {
                width: 100%;
                grid-template-columns: 1fr;
            }
        }

        /* Hide mobile chat UI by default (desktop), show only on mobile */
        @media (min-width: 769px) {

            #mobile-chat-fab,
            #mobile-chat-sheet {
                display: none;
            }
        }

        @media (max-width: 768px) {
            .mobile-chat-fab {
                position: fixed;
                right: 16px;
                bottom: 156px;
                background: #111827;
                color: #fff;
                border: 1px solid rgba(255, 255, 255, .12);
                padding: .6rem .9rem;
                border-radius: 999px;
                box-shadow: var(--shadow);
                z-index: 1200;
                display: inline-flex;
                align-items: center;
            }

            .mobile-chat-sheet {
                position: fixed;
                left: 0;
                right: 0;
                bottom: -100%;
                height: 70vh;
                background: #0f172a;
                border-top: 1px solid var(--border);
                border-radius: 16px 16px 0 0;
                display: flex;
                flex-direction: column;
                transition: transform .25s ease;
                transform: translateY(100%);
                z-index: 1300;
            }

            /* Ensure visibility on mobile */
            #mobile-chat-fab {
                display: inline-flex !important;
                z-index: 2000;
            }

            #mobile-chat-sheet {
                display: flex !important;
                z-index: 2100;
            }
        }
    </style>
    <script type="importmap">
    { 
      "imports": { 
        "three": "https://unpkg.com/three@0.149.0/build/three.module.js", 
        "three/addons/": "https://unpkg.com/three@0.149.0/examples/jsm/",
        "lipsync-en": "https://cdn.jsdelivr.net/gh/met4citizen/TalkingHead@1.2/modules/lipsync-en.mjs"
      } 
    }
    </script>
</head>

<body>

    <div id="setup-screen" class="setup-container">
        <div class="setup-card fade-in">
            <div class="setup-header">
                <div class="setup-logo">
                    <svg width="32" height="32" viewBox="0 0 24 24" fill="white">
                        <path
                            d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z" />
                    </svg>
                </div>
                <h1 class="setup-title">AI Video Interview</h1>
                <p class="setup-subtitle">Practice with our AI interviewer and get instant feedback on your performance
                </p>
            </div>

            <form id="setup-form" class="form-grid">
                <div class="form-group">
                    <label class="form-label" for="specialization">Target Role</label>
                    <div class="select-wrapper">
                        <select id="specialization" class="form-select">
                            <optgroup label="CA & Accounting (Recommended)">
                                <option value="Chartered Accountant - Audit" selected>Chartered Accountant — Audit
                                </option>
                                <option value="Chartered Accountant - Taxation">Chartered Accountant — Taxation</option>
                                <option value="Management Accountant (CMA)">Management Accountant (CMA)</option>
                                <option value="Financial Controller">Financial Controller</option>
                                <option value="Statutory Auditor">Statutory Auditor</option>
                                <option value="IFRS Specialist">IFRS Specialist</option>
                                <option value="GST/Indirect Tax Specialist">GST / Indirect Tax Specialist</option>
                                <option value="Direct Tax Consultant">Direct Tax Consultant</option>
                                <option value="Risk & Compliance (SOX/ICFR)">Risk & Compliance (SOX / ICFR)</option>
                                <option value="Treasury Analyst">Treasury Analyst</option>
                                <option value="Corporate Finance Associate">Corporate Finance Associate</option>
                                <option value="Forensic Accountant">Forensic Accountant</option>
                            </optgroup>
                            <optgroup label="Other Roles">
                                <option value="Finance Analyst">Finance Analyst</option>
                                <option value="Business Analyst">Business Analyst</option>
                                <option value="Product Manager">Product Manager</option>
                                <option value="Data Scientist">Data Scientist</option>
                                <option value="Software Engineer">Software Engineer</option>
                                <option value="UX Designer">UX Designer</option>
                                <option value="Marketing Manager">Marketing Manager</option>
                                <option value="Sales Representative">Sales Representative</option>
                            </optgroup>
                        </select>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label" for="experience-level">Experience Level</label>
                    <div class="select-wrapper">
                        <select id="experience-level" class="form-select">
                            <option value="Article/Intern">Article/Intern</option>
                            <option value="Entry Level" selected>Entry Level (0-2 years)</option>
                            <option value="Mid Level">Mid Level (3-5 years)</option>
                            <option value="Senior Level">Senior Level (6-10 years)</option>
                            <option value="Executive Level">Executive Level (10+ years)</option>
                        </select>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label" for="company-type">Company Type</label>
                    <div class="select-wrapper">
                        <select id="company-type" class="form-select">
                            <option value="Big 4 (Audit/Tax)">Big 4 (Audit/Tax)</option>
                            <option value="Mid-size CA Firm">Mid-size CA Firm</option>
                            <option value="Corporate (Industry)">Corporate (Industry)</option>
                            <option value="Consulting Firm">Consulting Firm</option>
                            <option value="Fortune 500">Fortune 500</option>
                            <option value="Tech Startup">Tech Startup</option>
                            <option value="Healthcare">Healthcare</option>
                            <option value="Government">Government</option>
                            <option value="Non-Profit">Non-Profit</option>
                            <option value="Investment Bank">Investment Bank</option>
                        </select>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label" for="interview-duration">Interview Duration</label>
                    <div class="select-wrapper">
                        <select id="interview-duration" class="form-select">
                            <option value="15">15 minutes</option>
                            <option value="30" selected>30 minutes</option>
                            <option value="45">45 minutes</option>
                            <option value="60">60 minutes</option>
                        </select>
                    </div>
                </div>

                <button type="submit" class="btn btn-primary">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M8 5v14l11-7z" />
                    </svg>
                    Start Interview
                </button>
            </form>
        </div>
    </div>


    <div id="loading-screen" class="loading-screen hidden">
        <div class="loading-spinner"></div>
        <div class="loading-text">Preparing your interview...</div>
        <div class="loading-progress">
            <div class="loading-progress-bar" id="loading-progress-bar"></div>
        </div>
    </div>


    <div id="permissions-modal" class="permissions-modal hidden">
        <div class="permissions-content">
            <h2 class="permissions-title">Camera & Microphone Access</h2>
            <p class="permissions-text">
                To provide the best interview experience, we need access to your camera and microphone.
                This helps our AI interviewer analyze your verbal and non-verbal communication.
            </p>
            <div class="permissions-actions">
                <button id="allow-permissions" class="btn btn-primary">Allow Access</button>
                <button id="skip-permissions" class="btn"
                    style="background: var(--bg-tertiary); color: var(--text-primary);">Skip for now</button>
            </div>
        </div>
    </div>


    <div id="interview-screen" class="interview-container hidden">
        <header class="interview-header">
            <div class="interview-title">
                AI Video Interview - <span id="current-role">Software Engineer</span>
                <span class="pills">
                    <span id="score-pill" class="pill success">Avg Score: —</span>
                    <span id="progress-pill" class="pill info">Progress: 0%</span>
                </span>
            </div>
            <div class="interview-controls">
            </div>
        </header>

        <main class="interview-main">
            <div class="main-video">
                <div id="avatar-container" class="avatar-container">
                    <div id="model-loading-overlay" class="model-loading-overlay">
                        <div class="loading-spinner"></div>
                        <div style="color: var(--text-secondary); margin-top: 1rem;">Loading AI Interviewer...</div>
                    </div>
                </div>
                <div class="video-overlay">
                    <div class="participant-info">
                        Aditya Chourasia - AI Interviewer
                    </div>
                    <div class="video-status">
                        <div class="status-indicator" id="ai-audio-status"></div>
                    </div>
                </div>
                <div id="subtitles-overlay" class="subtitles-overlay hidden"></div>
            </div>

            <aside class="sidebar">
                <div class="user-video">
                    <video id="user-video" autoplay muted playsinline></video>
                    <div class="video-overlay" style="bottom: 0.5rem; left: 0.5rem; right: 0.5rem;">
                        <div class="participant-info" style="font-size: 0.8rem;">
                            You
                        </div>
                        <div class="video-status">
                            <div class="status-indicator" id="user-audio-status"></div>
                        </div>
                    </div>
                </div>

                <div class="chat-section">
                    <div id="chat-messages" class="chat-messages"></div>
                </div>
            </aside>
        </main>

        <footer class="interview-footer">
            <div class="footer-controls">
                <button id="subtitles-btn" class="footer-btn subtitles" title="Toggle Subtitles">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path
                            d="M19 4H5c-1.66 0-3.15.25-4.6.72v3.1c0 .39-.23.74-.56.9-.98.49-1.87 1.12-2.66 1.85-.18.18-.43.28-.7.28-.28 0-.53-.11-.71-.29L.29 13.08c-.18-.17-.29-.42-.29-.7 0-.28.11-.53.29-.71C3.34 8.78 7.46 7 12 7s8.66 1.78 11.71 4.67c.18.18.29.43.29.71 0 .28-.11.53-.29.71l-2.48 2.48c-.18.18-.43.29-.71.29-.79-.73-1.68-1.36-2.66-1.85-.33-.16-.56-.51-.56-.9v-3.1C15.15 9.25 13.6 9 12 9z" />
                    </svg>
                </button>
                <button id="end-call-btn" class="footer-btn end-call" title="End Interview">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path
                            d="M12 9c-1.66 0-3.15.25-4.6.72v3.1c0 .39-.23.74-.56.9-.98.49-1.87 1.12-2.66 1.85-.18.18-.43.28-.7.28-.28 0-.53-.11-.71-.29L.29 13.08c-.18-.17-.29-.42-.29-.7 0-.28.11-.53.29-.71C3.34 8.78 7.46 7 12 7s8.66 1.78 11.71 4.67c.18.18.29.43.29.71 0 .28-.11.53-.29.71l-2.48 2.48c-.18.18-.43.29-.71.29-.79-.73-1.68-1.36-2.66-1.85-.33-.16-.56-.51-.56-.9v-3.1C15.15 9.25 13.6 9 12 9z" />
                    </svg>
                </button>
            </div>
        </footer>


        <div class="floating-ptt" aria-live="polite">
            <div class="push-to-talk-container">
                <button id="push-to-talk-btn" class="push-to-talk-btn" title="Hold to speak" aria-label="Hold to speak">
                    <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                        <path
                            d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.49 6-3.31 6-6.72h-1.7z" />
                    </svg>
                </button>
                <div id="speech-status" class="speech-status" role="status" aria-live="polite"></div>
                <span class="push-to-talk-hint">Hold to speak, release to send</span>
            </div>
        </div>

        <div id="mobile-chat-fab" class="mobile-chat-fab" aria-label="Open chat">Chat</div>
        <div id="mobile-chat-sheet" class="mobile-chat-sheet" aria-hidden="true">
            <div class="sheet-header">
                <span>Chat</span>
                <button id="mobile-chat-close" class="sheet-close" aria-label="Close">×</button>
            </div>
            <div id="mobile-chat-messages" class="sheet-messages"></div>
            <div class="sheet-input">
                <input id="mobile-chat-input" type="text" placeholder="Type your message..." />
                <button id="mobile-send-btn" class="btn btn-primary">Send</button>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { LipsyncEn } from 'lipsync-en';
        import { poses, moods, emojis, gestures } from 'https://www.mystudentclub.com/scripts/animations.js';

        // --- CONFIGURATION ---
        const AVATAR_URL = 'https://models.readyplayer.me/69440c84ca696e5f2fb7bfd5.glb?morphTargets=ARKit,Oculus+Visemes,mouthOpen,mouthSmile,eyesClosed,eyesLookUp,eyesLookDown';
        const WORKER_URL = 'https://interviewme.bhansalimanan55.workers.dev/';
        const TTS_ENDPOINT = 'https://us-central1-msc-notif.cloudfunctions.net/gcp-tts-rate-limited';

        // --- GLOBAL CONTROLS ---
        window.speechRecognitionActive = false; // Flag to track state

        // --- TALKING HEAD CLASS ---
        class TalkingHead {
            constructor(node, opt = {}) {
                this.nodeAvatar = node;
                this.opt = { ttsEndpoint: null, lipsyncLang: 'en', cameraView: 'upper', ...opt };
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.setSize(node.clientWidth, node.clientHeight);
                this.renderer.outputColorSpace = THREE.SRGBColorSpace;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.nodeAvatar.appendChild(this.renderer.domElement);
                this.camera = new THREE.PerspectiveCamera(25, node.clientWidth / node.clientHeight, 0.1, 100);
                this.scene = new THREE.Scene();

                this.scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.7));
                const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
                dirLight.position.set(0.5, 2, 2);
                dirLight.castShadow = true;
                this.scene.add(dirLight);

                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableZoom = false; this.controls.enablePan = false;
                this.controls.target.set(0, 1.58, 0); this.controls.enableDamping = true;

                this.animClock = 0; this.animTimeLast = 0;
                this.avatar = null; this.armature = null; this.morphs = []; this.mixer = null;
                this.speechQueue = []; this.isSpeaking = false; this.isRunning = false;
                this.audioCtx = new AudioContext(); this.audioSpeechSource = null;
                this.lipsync = {};
                this.visemeNames = ['viseme_sil', 'viseme_PP', 'viseme_FF', 'viseme_TH', 'viseme_DD', 'viseme_kk', 'viseme_CH', 'viseme_SS', 'viseme_nn', 'viseme_RR', 'viseme_aa', 'viseme_E', 'viseme_I', 'viseme_O', 'viseme_U'];

                this.poseTemplates = poses; this.animMoods = moods; this.animEmojis = emojis; this.gestureTemplates = gestures || {};

                this.animQueue = []; this.poseBase = { props: {} }; this.poseTarget = { props: {} }; this.poseAvatar = { props: {} }; this.poseDelta = { props: {} }; this.animBaseline = {};
                this.currentPoseName = 'straight';
                this.easing = t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

                window.addEventListener('resize', this.onResize.bind(this));
            }

            async init() {
                this.lipsync[this.opt.lipsyncLang] = new LipsyncEn();
                try {
                    const rgbe = new RGBELoader();
                    const tex = await new Promise((res, rej) => rgbe.load('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_09_1k.hdr', res, undefined, rej));
                    tex.mapping = THREE.EquirectangularReflectionMapping; this.scene.environment = tex;
                } catch (e) { }
            }

            async showAvatar(avatar) {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync(avatar.url);
                this.armature = gltf.scene;
                this.armature.traverse(node => {
                    if (node.isMesh) {
                        node.castShadow = true; node.receiveShadow = true; node.frustumCulled = false;
                        if (node.material) { node.material.transparent = false; node.material.alphaTest = 0.5; node.material.side = THREE.FrontSide; if (node.name.toLowerCase().includes('eye')) { node.material.roughness = 0.2; node.material.metalness = 0.1; } }
                        if (node.morphTargetDictionary) this.morphs.push(node);
                    }
                });

                this.poseAvatar = { props: {} }; this.poseDelta = { props: {} };
                if (!this.poseTemplates.straight) this.poseTemplates.straight = { props: {} };
                this.poseBase = this.poseFactory(this.poseTemplates.straight);
                this.poseTarget = this.poseFactory(this.poseTemplates.straight);

                const usedBones = new Set();
                [...Object.values(this.poseTemplates), ...Object.values(this.gestureTemplates)].forEach(t => {
                    if (t.props) Object.keys(t.props).forEach(k => usedBones.add(k));
                    else Object.keys(t).forEach(k => usedBones.add(k));
                });

                usedBones.forEach(key => {
                    const [boneName, prop] = key.split('.');
                    const bone = this.armature.getObjectByName(boneName);
                    if (bone) {
                        this.poseAvatar.props[key] = bone[prop];
                        if (!this.poseBase.props[key]) this.poseBase.props[key] = bone[prop].clone();
                        if (!this.poseTarget.props[key]) this.poseTarget.props[key] = bone[prop].clone();
                        if (prop === 'rotation' || prop === 'quaternion') this.poseDelta.props[key] = new THREE.Euler();
                        else this.poseDelta.props[key] = new THREE.Vector3();
                    }
                });

                this.setPose('straight', 0);
                this.scene.add(this.armature);
                this.setView(this.opt.cameraView);
                this.start();
            }

            start() { if (this.isRunning) return; this.isRunning = true; this.animTimeLast = performance.now(); this.setMood('neutral'); this.renderer.setAnimationLoop(this.animate.bind(this)); }
            setMood(n) { if (!this.animMoods[n]) return; this.animQueue = this.animQueue.filter(a => a.loop !== -1); this.animMoods[n].anims.forEach(a => this.animQueue.push(this.animFactory(a))); if (this.animMoods[n].baseline) Object.entries(this.animMoods[n].baseline).forEach(([k, v]) => this.animBaseline[k] = { target: v, t0: this.animClock, v0: this.getValue(k) }); }

            animate() {
                const now = performance.now(); const dt = now - this.animTimeLast; this.animClock += dt; this.animTimeLast = now; this.controls.update();
                const cv = new Map();
                for (let [mt, x] of Object.entries(this.animBaseline)) {
                    if (x.t0 === undefined) { x.t0 = this.animClock; x.v0 = this.getValue(mt); }
                    cv.set(mt, this.valueAnimationSeq([x.t0, x.t0 + 1000], [x.v0, x.target], this.animClock));
                }
                for (let i = 0; i < this.animQueue.length; i++) {
                    const anim = this.animQueue[i];
                    if (this.animClock < anim.ts[0]) continue;
                    Object.entries(anim.vs).forEach(([mt, vs]) => {
                        if (vs[0] === null) vs[0] = this.getValue(mt) || 0;
                        const val = this.valueAnimationSeq(anim.ts, vs, this.animClock);
                        if (mt === 'pose') {
                            const pName = vs[Math.max(0, anim.ts.findIndex(t => t > this.animClock) - 1)];
                            if (pName && pName !== this.currentPoseName) this.setPose(pName);
                        } else if (mt === 'gesture') {
                            const gData = vs[Math.max(0, anim.ts.findIndex(t => t > this.animClock) - 1)];
                            if (Array.isArray(gData) && !anim._triggered) { this.playGesture(gData[0], gData[1]); anim._triggered = true; }
                        } else {
                            if (Math.abs(val) >= Math.abs(cv.get(mt) || 0)) cv.set(mt, val);
                        }
                    });
                    if (this.animClock >= anim.ts.at(-1)) { if (anim.loop === -1) this.animQueue[i] = this.animFactory(anim.template); else this.animQueue.splice(i--, 1); }
                }
                this.applyValues(cv); this.updatePoseBase(); this.renderer.render(this.scene, this.camera);
            }

            applyValues(values) {
                // SMOOTH BLENDSHAPE LOGIC (Fixes Flapping)
                for (const mesh of this.morphs) {
                    for (const name in mesh.morphTargetDictionary) {
                        const idx = mesh.morphTargetDictionary[name];
                        let targetVal = values.get(name);

                        // Default decay if no target
                        if (targetVal === undefined) {
                            const c = mesh.morphTargetInfluences[idx] || 0;
                            targetVal = name.startsWith('viseme_') ? 0 : c * 0.95;
                        }

                        // Cap Mouth Opening (Prevent Gaping)
                        if (name.startsWith('viseme_')) {
                            targetVal = Math.min(0.6, targetVal);
                        } else {
                            targetVal = Math.min(1.0, targetVal);
                        }

                        // LERP (Smoothing) - The key to fixing flapping
                        const currentVal = mesh.morphTargetInfluences[idx];
                        const smoothingSpeed = name.startsWith('viseme_') ? 0.4 : 0.1; // Higher = faster
                        const nextVal = THREE.MathUtils.lerp(currentVal, targetVal, smoothingSpeed);

                        mesh.morphTargetInfluences[idx] = Math.max(0, nextVal);
                    }
                }

                const hX = values.get('headRotateX') || 0, hY = values.get('headRotateY') || 0, hZ = values.get('headRotateZ') || 0, chest = values.get('chestInhale') || 0;
                if (this.poseDelta.props['Head.rotation']) this.poseDelta.props['Head.rotation'].set(hX, hY, hZ);
                if (this.poseDelta.props['Spine1.rotation']) this.poseDelta.props['Spine1.rotation'].set(-chest * 0.05, 0, 0);
                Object.keys(this.poseAvatar.props).forEach(k => {
                    const b = this.poseAvatar.props[k], base = this.poseBase.props[k]; if (!b || !base) return;
                    if (b.isQuaternion) { b.copy(base); const [n] = k.split('.'); const d = this.poseDelta.props[`${n}.rotation`]; if (d) b.multiply(new THREE.Quaternion().setFromEuler(d)); }
                    else if (b.isVector3) { b.copy(base); if (k === 'Spine1.scale' && chest > 0) b.set(1 + (chest * 0.1), 1 + (chest * 0.1), 1 + (chest * 0.1)); }
                });
                const lEye = this.armature.getObjectByName('LeftEye'), rEye = this.armature.getObjectByName('RightEye');
                if (lEye && rEye) { const eX = values.get('eyesRotateX') || 0, eY = values.get('eyesRotateY') || 0; lEye.rotation.set(eX, eY, 0); rEye.rotation.set(eX, eY, 0); }
            }

            setPose(name, ms = 2000) {
                if (!this.poseTemplates[name]) return; this.currentPoseName = name; const t = this.poseTemplates[name], p = {};
                Object.keys(t.props).forEach(k => { const v = t.props[k]; if (k.includes('rotation')) p[k] = new THREE.Quaternion().setFromEuler(new THREE.Euler(v.x, v.y, v.z)); else p[k] = new THREE.Vector3(v.x, v.y, v.z); });
                this.poseTarget.props = p; Object.values(this.poseTarget.props).forEach(v => { v.t = this.animClock; v.d = ms; });
            }
            playGesture(name, dur = 1) {
                const g = this.gestureTemplates[name]; if (!g) return;
                Object.keys(g).forEach(k => { const v = g[k]; if (this.poseTarget.props[k]) { this.poseTarget.props[k].copy(new THREE.Quaternion().setFromEuler(new THREE.Euler(v.x, v.y, v.z))); this.poseTarget.props[k].t = this.animClock; this.poseTarget.props[k].d = 500; } });
                setTimeout(() => this.setPose(this.currentPoseName, 1000), dur * 1000);
            }
            updatePoseBase() { for (const [k, t] of Object.entries(this.poseTarget.props)) { const b = this.poseBase.props[k]; if (!b) continue; const a = Math.min(1, (this.animClock - t.t) / t.d); if (a >= 1) b.copy(t); else { if (b.isQuaternion) b.slerp(t, this.easing(a)); else b.lerp(t, this.easing(a)); } } }

            async processSpeechItem(item) {
                // HARD STOP MIC
                if (window.stopListening) window.stopListening();

                this.isSpeaking = true;

                if (item.type === 'text') {
                    try {
                        const pre = this.lipsync.en.preProcessText(item.content);
                        const res = await fetch(this.opt.ttsEndpoint, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ text: pre }) });
                        if (!res.ok) throw new Error("TTS Error");
                        const data = await res.json();
                        await this.playAudioWithVisemes(data.audioContent, data.timepoints);
                    } catch (e) { console.error(e); this.finishSpeaking(); }
                } else if (item.type === 'emoji') {
                    const anim = this.animFactory(this.animEmojis[item.content] || this.animEmojis['😊']);
                    this.animQueue.push(anim);
                    setTimeout(() => this.finishSpeaking(), anim.ts.at(-1) - this.animClock);
                }
            }

            async playAudioWithVisemes(base64, timepoints) {
                if (this.audioCtx.state === 'suspended') await this.audioCtx.resume();
                this.animQueue = this.animQueue.filter(a => !Object.keys(a.vs)[0].startsWith('viseme_'));

                const audioData = Uint8Array.from(atob(base64), c => c.charCodeAt(0)).buffer;
                const buffer = await this.audioCtx.decodeAudioData(audioData);
                const duration = buffer.duration * 1000;

                const audioStart = this.animClock + 50;
                timepoints.forEach((tp, idx) => {
                    const next = timepoints[idx + 1];
                    const wordDur = next ? (next.time_seconds - tp.time_seconds) * 1000 : 200;
                    const vis = this.lipsync.en.wordsToVisemes(tp.word);
                    if (vis.visemes.length) {
                        const totalRel = vis.durations.reduce((a, b) => a + b, 0);
                        vis.visemes.forEach((v, i) => {
                            const absStart = (tp.time_seconds * 1000) + (vis.times[i] / totalRel * wordDur);
                            const absDur = (vis.durations[i] / totalRel * wordDur);
                            const finalDur = Math.max(80, absDur); // Longer duration for smoother look
                            const t = audioStart + absStart;
                            this.animQueue.push({
                                ts: [t, t + (finalDur * 0.5), t + finalDur],
                                vs: { [`viseme_${v}`]: [0, 1, 0] } // 1.0 is fine here because applyValues caps it
                            });
                        });
                    }
                });

                if (this.audioSpeechSource) this.audioSpeechSource.stop();
                this.audioSpeechSource = this.audioCtx.createBufferSource();
                this.audioSpeechSource.buffer = buffer;
                this.audioSpeechSource.connect(this.audioCtx.destination);
                this.audioSpeechSource.start(this.audioCtx.currentTime + 0.05);

                if (typeof scheduleAISubtitles === 'function') scheduleAISubtitles(timepoints, buffer.duration, this.audioCtx.currentTime + 0.05);

                this.audioSpeechSource.onended = () => {
                    // Small buffer before listening again to clear room echo
                    setTimeout(() => this.finishSpeaking(), 800);
                };
            }

            stopSpeaking() {
                if (this.audioSpeechSource) { this.audioSpeechSource.stop(); this.audioSpeechSource = null; }
                this.speechQueue = []; this.finishSpeaking();
            }

            speakText(t) { if (this.isSpeaking) { this.speechQueue.push({ type: 'text', content: t }); return; } this.processSpeechItem({ type: 'text', content: t }); }
            speakEmoji(e) { if (this.isSpeaking) { this.speechQueue.push({ type: 'emoji', content: e }); return; } this.processSpeechItem({ type: 'emoji', content: this.animEmojis[e] }); }
            finishSpeaking() {
                this.isSpeaking = false;
                this.start();
                if (this.speechQueue.length) {
                    this.processSpeechItem(this.speechQueue.shift());
                } else {
                    // Only start listening if queue is empty
                    if (window.startListening) window.startListening();
                }
            }

            getValue(n) { if (n.startsWith('headRotate')) return this.poseDelta.props['Head.rotation']?.[n.slice(-1).toLowerCase()] || 0; const m = this.morphs[0]; return (m && m.morphTargetDictionary[n] !== undefined) ? m.morphTargetInfluences[m.morphTargetDictionary[n]] : 0; }
            poseFactory(t, ms = 2000) { const p = {}; if (t.props) Object.keys(t.props).forEach(k => { const v = t.props[k]; if (k.includes('rotation')) p[k] = new THREE.Quaternion().setFromEuler(new THREE.Euler(v.x, v.y, v.z)); else p[k] = new THREE.Vector3(v.x, v.y, v.z); }); return { props: p }; }
            animFactory(t) { const i = { template: t, ts: [], vs: {}, loop: t.loop }; let c = this.animClock + (Array.isArray(t.delay) ? (t.delay[0] + Math.random() * (t.delay[1] - t.delay[0])) : (t.delay || 0)); i.ts.push(c); (t.dt || [1000]).forEach(d => { c += Array.isArray(d) ? (d[0] + Math.random() * (d[1] - d[0])) : d; i.ts.push(c); }); Object.keys(t.vs).forEach(k => { i.vs[k] = t.vs[k].map(v => Array.isArray(v) ? v[0] + Math.random() * (v[1] - v[0]) : v); while (i.vs[k].length < i.ts.length) i.vs[k].push(i.vs[k].at(-1)); }); return i; }
            valueAnimationSeq(ts, vs, t) { if (t <= ts[0]) return vs[0]; if (t >= ts.at(-1)) return vs.at(-1); let i = ts.findIndex(time => time > t) - 1; if (i < 0) i = 0; const p = (t - ts[i]) / (ts[i + 1] - ts[i]); return vs[i] + (vs[i + 1] - vs[i]) * this.easing(p); }
            onResize() { this.camera.aspect = this.nodeAvatar.clientWidth / this.nodeAvatar.clientHeight; this.camera.updateProjectionMatrix(); this.renderer.setSize(this.nodeAvatar.clientWidth, this.nodeAvatar.clientHeight); }
            setView(v) { this.camera.position.set(0, 1.55, 0.85); }
        }

        // --- GLOBAL LOGIC ---
        let avatar, userStream, isModelLoaded = false, areSubtitlesOn = true, interviewConfig = {}, messages = [], speechRecognition, isWaitingForAIResponse = false;

        const EMOJI_CHAR = /[\u{1F300}-\u{1FAFF}\u{2600}-\u{27BF}]/u;
        function extractEmojisAndSanitize(text = "") {
            const reportRegex = /<<<FINAL_INTERVIEW_REPORT>>>[\s\S]*?<<<END_FINAL_INTERVIEW_REPORT>>>/;
            const reportMatch = text.match(/<<<FINAL_INTERVIEW_REPORT>>>([\s\S]*?)<<<END_FINAL_INTERVIEW_REPORT>>>/);
            let clean = text.replace(reportRegex, "").replace(/\*/g, "");
            const chars = Array.from(clean), emojis = [];
            clean = chars.map(ch => EMOJI_CHAR.test(ch) ? (emojis.push(ch), "") : ch).join("").trim();
            return { clean, emojis, report: reportMatch ? reportMatch[1] : null };
        }

        const setupScreen = document.getElementById('setup-screen'), loadingScreen = document.getElementById('loading-screen'), permissionsModal = document.getElementById('permissions-modal'), interviewScreen = document.getElementById('interview-screen'), setupForm = document.getElementById('setup-form'), avatarContainer = document.getElementById('avatar-container'), modelLoadingOverlay = document.getElementById('model-loading-overlay'), chatMessages = document.getElementById('chat-messages'), userVideo = document.getElementById('user-video'), subtitlesOverlay = document.getElementById('subtitles-overlay'), currentRoleSpan = document.getElementById('current-role'), loadingProgressBar = document.getElementById('loading-progress-bar'), speechStatus = document.getElementById('speech-status'), subtitlesBtn = document.getElementById('subtitles-btn'), endCallBtn = document.getElementById('end-call-btn'), allowPermissionsBtn = document.getElementById('allow-permissions'), skipPermissionsBtn = document.getElementById('skip-permissions');
        document.getElementById('push-to-talk-btn').style.display = 'none';

        async function init() {
            setupEventListeners();
            setupContinuousSpeechRecognition();
            loadModelInBackground();
            subtitlesBtn.classList.toggle('active', areSubtitlesOn);
        }

        function setupEventListeners() {
            setupForm.addEventListener('submit', handleSetupSubmit);
            subtitlesBtn.addEventListener('click', toggleSubtitles);
            endCallBtn.addEventListener('click', endInterview);
            if (allowPermissionsBtn) allowPermissionsBtn.addEventListener('click', requestPermissions);
            if (skipPermissionsBtn) skipPermissionsBtn.addEventListener('click', skipPermissions);
            window.addEventListener('resize', () => { if (avatar) avatar.onResize(); });
        }

        // --- GLOBAL MIC CONTROLS (THE HARD FIX) ---
        window.startListening = function () {
            if (speechRecognition && !isWaitingForAIResponse) {
                try { speechRecognition.start(); } catch (e) { /* ignore already started errors */ }
            }
        };

        window.stopListening = function () {
            if (speechRecognition) {
                try { speechRecognition.stop(); } catch (e) { }
            }
        };

        function setupContinuousSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                speechRecognition = new SpeechRecognition();
                speechRecognition.continuous = true;
                speechRecognition.interimResults = true;
                speechRecognition.lang = 'en-US';

                speechRecognition.onresult = (event) => {
                    // Logic gate: If AI is theoretically speaking, reject everything.
                    if (avatar && avatar.isSpeaking) {
                        return; // Ignore inputs completely
                    }

                    let finalTranscript = '';
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        if (event.results[i].isFinal) {
                            const spoken = event.results[i][0].transcript.trim();
                            if (spoken) handleSpeechInput(spoken);
                        }
                    }
                };

                speechRecognition.onend = () => {
                    // Auto-restart if we are supposed to be listening (not speaking)
                    if (!interviewScreen.classList.contains('hidden') && avatar && !avatar.isSpeaking && !isWaitingForAIResponse) {
                        try { speechRecognition.start(); } catch (e) { }
                    }
                };
            }
        }

        function handleSpeechInput(text) {
            if (!text.trim() || isWaitingForAIResponse) return;
            // Ignore short noise/echo remnants
            if (text.length < 3 && !['no', 'yes', 'ok'].includes(text.toLowerCase())) return;
            addChatMessage('user', 'You', text);
            window.stopListening(); // Stop immediately once we have a sentence
            sendToAI(text);
        }

        function updateSpeechStatus(t, v) { speechStatus.textContent = t; speechStatus.classList.toggle('visible', v); }

        async function loadModelInBackground() {
            try {
                avatar = new TalkingHead(avatarContainer, { ttsEndpoint: TTS_ENDPOINT, cameraView: 'head' });
                await avatar.init();
                updateLoadingProgress(30, 'Loading 3D model...');
                await avatar.showAvatar({ url: AVATAR_URL });
                updateLoadingProgress(100, 'Ready!');
                isModelLoaded = true;
                modelLoadingOverlay.classList.add('hidden');
                loadingScreen.classList.add('hidden');
            } catch (error) { console.error(error); updateLoadingProgress(0, 'Failed.'); }
        }
        function updateLoadingProgress(p, t) { loadingProgressBar.style.width = `${p}%`; const lt = document.querySelector('.loading-text'); if (lt) lt.textContent = t; }

        async function handleSetupSubmit(e) {
            e.preventDefault();
            interviewConfig = { specialization: document.getElementById('specialization').value, experienceLevel: document.getElementById('experience-level').value, companyType: document.getElementById('company-type').value, duration: document.getElementById('interview-duration').value };
            currentRoleSpan.textContent = interviewConfig.specialization;
            setupScreen.classList.add('hidden');
            if (!isModelLoaded) { loadingScreen.classList.remove('hidden'); while (!isModelLoaded) await new Promise(r => setTimeout(r, 100)); loadingScreen.classList.add('hidden'); }
            try { await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true } }); skipPermissions(); } catch (error) { permissionsModal.classList.remove('hidden'); }
        }
        function skipPermissions() { permissionsModal.classList.add('hidden'); startInterview(); }
        async function requestPermissions() { try { await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true } }); skipPermissions(); } catch (e) { skipPermissions(); } }

        async function startInterview() {
            interviewScreen.classList.remove('hidden');
            messages = []; isWaitingForAIResponse = false;
            await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: { echoCancellation: true, noiseSuppression: true } })
                .then(stream => { userStream = stream; if (userVideo) { userVideo.srcObject = stream; userVideo.play(); } })
                .catch(e => console.log(e));

            setTimeout(() => avatar && avatar.onResize(), 50);

            const welcome = "Hello, I'm Aditya. Let's get started. Please walk me through your background.";
            addChatMessage('ai', 'Aditya Chourasia', welcome);
            if (avatar) avatar.speakText(welcome);
            if (areSubtitlesOn) scheduleAISubtitles([{ word: "Hello,", time_seconds: 0 }, { word: "I'm", time_seconds: 0.3 }, { word: "Aditya.", time_seconds: 0.5 }, { word: "Let's", time_seconds: 1.0 }, { word: "get", time_seconds: 1.2 }, { word: "started.", time_seconds: 1.5 }], 3.0, 0);
        }

        function addChatMessage(type, author, content) {
            const el = document.createElement('div');
            el.className = `message ${type}`;
            el.innerHTML = `<div class="message-author">${author}</div><div class="message-content">${content}</div>`;
            chatMessages.appendChild(el); chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        async function sendToAI(message) {
            if (isWaitingForAIResponse) return; isWaitingForAIResponse = true;
            try {
                messages.push({ role: 'user', content: message });
                const response = await fetch(WORKER_URL, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-Specialization': interviewConfig.specialization, 'X-Experience-Level': interviewConfig.experienceLevel, 'X-Company-Type': interviewConfig.companyType, 'X-Duration': interviewConfig.duration }, body: JSON.stringify({ messages }) });
                const data = await response.json();
                if (data.ok && data.response) {
                    let aiMessage = data.response;
                    const { clean, emojis, report } = extractEmojisAndSanitize(aiMessage);

                    if (report) {
                        messages.push({ role: 'assistant', content: aiMessage });
                        addChatMessage('ai', 'System', `<b>Interview Report Generated</b><div style="font-size:0.85em; margin-top:5px; white-space:pre-wrap; opacity:0.9">${report}</div>`);
                        if (clean.length > 2) {
                            addChatMessage('ai', 'Aditya Chourasia', clean);
                            if (avatar && isModelLoaded) avatar.speakText(clean);
                        }
                    } else {
                        messages.push({ role: 'assistant', content: aiMessage });
                        addChatMessage('ai', 'Aditya Chourasia', clean);
                        if (avatar && isModelLoaded) {
                            emojis.forEach((e, i) => setTimeout(() => avatar.speakEmoji(e), i * 500));
                            avatar.speakText(clean);
                        }
                    }
                }
            } catch (error) { console.error(error); addChatMessage('ai', 'System', 'Connection error.'); } finally { isWaitingForAIResponse = false; }
        }

        function showSubtitles(text) { subtitlesOverlay.textContent = text; subtitlesOverlay.classList.remove('hidden'); }
        window.clearAISubtitles = function () {
            if (subtitlesOverlay._sched) subtitlesOverlay._sched.forEach(id => clearTimeout(id));
            subtitlesOverlay._sched = [];
            subtitlesOverlay.classList.add('hidden');
        };
        window.scheduleAISubtitles = function (timepoints, duration, startTime) {
            if (!areSubtitlesOn) return;
            window.clearAISubtitles();
            let currentLine = "";
            timepoints.forEach((tp) => {
                const delay = (tp.time_seconds * 1000);
                subtitlesOverlay._sched.push(setTimeout(() => {
                    if (currentLine.length > 60 || /[.!?]/.test(tp.word)) if (/[.!?]/.test(tp.word)) currentLine = "";
                    currentLine += " " + tp.word;
                    showSubtitles(currentLine.trim());
                }, delay));
            });
            subtitlesOverlay._sched.push(setTimeout(() => subtitlesOverlay.classList.add('hidden'), duration * 1000 + 1000));
        };

        function toggleSubtitles() { areSubtitlesOn = !areSubtitlesOn; subtitlesBtn.classList.toggle('active', areSubtitlesOn); if (!areSubtitlesOn) subtitlesOverlay.classList.add('hidden'); }
        function endInterview() { if (confirm('End interview?')) { if (userStream) userStream.getTracks().forEach(t => t.stop()); if (avatar) avatar.stopSpeaking(); try { window.stopListening(); } catch (e) { } interviewScreen.classList.add('hidden'); setupScreen.classList.remove('hidden'); isModelLoaded = false; location.reload(); } }

        // Custom Dropdown Implementation
        function initCustomSelects() {
            const selectorIds = ['specialization', 'experience-level', 'company-type', 'interview-duration'];

            // Close dropdowns on outside click
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.custom-select-wrapper')) {
                    document.querySelectorAll('.custom-select-wrapper.open').forEach(wrapper => {
                        wrapper.classList.remove('open');
                        const opts = wrapper.querySelector('.custom-options');
                        if (opts) {
                            opts.style.opacity = '0';
                            setTimeout(() => opts.style.display = 'none', 200);
                        }
                    });
                }
            });

            selectorIds.forEach(id => {
                const select = document.getElementById(id);
                if (!select) return;

                // Ensure we don't double-wrap if re-run
                if (select.parentNode.classList.contains('custom-select-wrapper')) return;

                // Create Custom UI
                const wrapper = document.createElement('div');
                wrapper.className = 'custom-select-wrapper custom-dropdown';

                const trigger = document.createElement('div');
                trigger.className = 'custom-select-trigger custom-dropdown-trigger';
                trigger.innerHTML = `<span>${select.options[select.selectedIndex]?.text || 'Select'}</span><div class="custom-dropdown-arrow">▾</div>`;

                const optionsList = document.createElement('div');
                optionsList.className = 'custom-options custom-dropdown-menu';

                // Function to rebuild options (handles optgroups)
                const buildOptions = () => {
                    optionsList.innerHTML = '';
                    Array.from(select.children).forEach(child => {
                        if (child.tagName === 'OPTGROUP') {
                            const groupLabel = document.createElement('div');
                            groupLabel.className = 'custom-dropdown-group-label';
                            groupLabel.textContent = child.label;
                            optionsList.appendChild(groupLabel);
                            
                            Array.from(child.children).forEach(opt => {
                                const div = document.createElement('div');
                                div.className = `custom-option custom-dropdown-option ${opt.selected ? 'selected' : ''}`;
                                div.textContent = opt.text;
                                div.dataset.value = opt.value;
                                div.addEventListener('click', (e) => {
                                    e.stopPropagation();
                                    select.value = opt.value;
                                    trigger.querySelector('span').textContent = opt.text;
                                    wrapper.classList.remove('open');
                                    optionsList.style.display = 'none';
                                    optionsList.querySelectorAll('.custom-option').forEach(o => o.classList.remove('selected'));
                                    div.classList.add('selected');
                                    select.dispatchEvent(new Event('change'));
                                });
                                optionsList.appendChild(div);
                            });
                        } else if (child.tagName === 'OPTION') {
                            const div = document.createElement('div');
                            div.className = `custom-option custom-dropdown-option ${child.selected ? 'selected' : ''}`;
                            div.textContent = child.text;
                            div.dataset.value = child.value;
                            div.addEventListener('click', (e) => {
                                e.stopPropagation();
                                select.value = child.value;
                                trigger.querySelector('span').textContent = child.text;
                                wrapper.classList.remove('open');
                                optionsList.style.display = 'none';
                                optionsList.querySelectorAll('.custom-option').forEach(o => o.classList.remove('selected'));
                                div.classList.add('selected');
                                select.dispatchEvent(new Event('change'));
                            });
                            optionsList.appendChild(div);
                        }
                    });
                };

                // Initial build
                buildOptions();

                // Assemble
                select.style.display = 'none';
                select.parentNode.insertBefore(wrapper, select);
                wrapper.appendChild(select);
                wrapper.appendChild(trigger);
                wrapper.appendChild(optionsList);

                // Toggle Event
                trigger.addEventListener('click', () => {
                    const isOpen = wrapper.classList.contains('open');
                    document.querySelectorAll('.custom-select-wrapper.open').forEach(w => {
                        if (w !== wrapper) {
                            w.classList.remove('open');
                            w.querySelector('.custom-options').style.display = 'none';
                        }
                    });

                    if (!isOpen) {
                        wrapper.classList.add('open');
                        optionsList.style.display = 'block';
                        optionsList.offsetHeight;
                        optionsList.style.opacity = '1';
                    } else {
                        wrapper.classList.remove('open');
                        optionsList.style.opacity = '0';
                        setTimeout(() => optionsList.style.display = 'none', 200);
                    }
                });

                // MutationObserver for option changes
                const observer = new MutationObserver(() => {
                    buildOptions();
                    const sel = select.options[select.selectedIndex];
                    if (sel) trigger.querySelector('span').textContent = sel.text;
                });
                observer.observe(select, { childList: true, subtree: true });

                // Intercept programmatic .value changes
                const descriptor = Object.getOwnPropertyDescriptor(HTMLSelectElement.prototype, 'value');
                Object.defineProperty(select, 'value', {
                    get: function() { return descriptor.get.call(this); },
                    set: function(val) {
                        descriptor.set.call(this, val);
                        const sel = this.options[this.selectedIndex];
                        if (sel) {
                            trigger.querySelector('span').textContent = sel.text;
                            optionsList.querySelectorAll('.custom-option').forEach(o => {
                                o.classList.toggle('selected', o.dataset.value === val);
                            });
                        }
                    }
                });

                // Listen for internal value changes
                select.addEventListener('change', () => {
                    const sel = select.options[select.selectedIndex];
                    if (sel) {
                        trigger.querySelector('span').textContent = sel.text;
                        optionsList.querySelectorAll('.custom-option').forEach(o => {
                            o.classList.toggle('selected', o.dataset.value === select.value);
                        });
                    }
                });
            });
        }

        // Initialize custom selects on load
        initCustomSelects();

        init();
    </script>

    <script defer src='https://static.cloudflareinsights.com/beacon.min.js'
        data-cf-beacon='{"token": "9ecf6f49919940acb2efcc833483cd5f"}'></script><!-- Cloudflare Pages Analytics -->
    <script defer src='https://static.cloudflareinsights.com/beacon.min.js'
        data-cf-beacon='{"token": "9ecf6f49919940acb2efcc833483cd5f"}'></script><!-- Cloudflare Pages Analytics -->
</body>

</html>