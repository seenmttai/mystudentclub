<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Video Interview - Professional Practice Platform</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #1e40af;
            --primary-light: #3b82f6;
            --secondary: #64748b;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --bg-primary: #0f172a;
            --bg-secondary: #111827; 
            --bg-tertiary: #1f2937;
            --text-primary: #f9fafb;
            --text-secondary: #e5e7eb;
            --text-muted: #94a3b8;
            --border: #374151;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            --border-radius: 12px;
            --transition: all 0.2s ease;
        }

        .hidden { display: none !important; }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .setup-container {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            position: relative;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
        }

        .subtitles-overlay {
        position: absolute;
        left: 50%;
        bottom: 76px;             
        transform: translateX(-50%);
        background: rgba(0,0,0,.65);
        color: #fff;
        padding: .6rem .9rem;
        border-radius: 10px;
        font-size: 1rem;
        line-height: 1.35;
        max-width: 88%;
        text-align: center;
        z-index: 20;                
        pointer-events: none;
        white-space: pre-wrap;
        }


        .setup-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23ffffff' fill-opacity='0.02'%3E%3Ccircle cx='30' cy='30' r='4'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E") repeat;
            opacity: 0.5;
        }

        .setup-card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 3rem;
            max-width: 600px;
            width: 100%;
            box-shadow: var(--shadow-lg);
            position: relative;
            z-index: 2;
        }

        .setup-header {
            text-align: center;
            margin-bottom: 2.5rem;
        }

        .setup-logo {
            width: 64px;
            height: 64px;
            background: linear-gradient(135deg, var(--primary), var(--primary-light));
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 1.5rem;
        }

        .setup-title {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--text-primary), var(--text-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
        }

        .setup-subtitle {
            color: var(--text-muted);
            font-size: 1.1rem;
            line-height: 1.6;
        }

        .form-grid {
            display: grid;
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-label {
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
        }

        .form-input, .form-select {
            padding: 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            color: var(--text-primary);
            font-size: 1rem;
            transition: var(--transition);
        }

        
        .select-wrapper {
            position: relative;
            display: block;
        }
        .select-wrapper::after {
            content: "â–¾";
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
            pointer-events: none;
            font-size: 0.95rem;
        }

        .form-select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            color-scheme: dark;
            width: 100%;
            line-height: 1.2;
            cursor: pointer;

            background-color: var(--bg-secondary); 
            color: var(--text-primary);
            border-color: var(--border);
        }

        .form-select:hover {
            background-color: #0b1220; 
        }

        .form-select:focus {
            outline: none;
            border-color: var(--primary-light);
            background-color: #0b1220;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25);
        }

        
        .form-select option,
        .form-select optgroup {
            background-color: #0b1220 !important; 
            color: #f9fafb !important;           
        }

        .form-select option:checked,
        .form-select option:focus,
        .form-select option:hover {
            background-color: #1e40af !important; 
            color: #ffffff !important;
        }

        
        @media (-ms-high-contrast: active) {
            .form-select {
                border: 2px solid windowText;
            }
        }

        
        .form-select::-webkit-scrollbar {
            width: 12px;
        }
        .form-select::-webkit-scrollbar-track {
            background: #0b1220;
        }
        .form-select::-webkit-scrollbar-thumb {
            background-color: #334155;
            border-radius: 8px;
            border: 3px solid #0b1220;
        }

        
        @-moz-document url-prefix() {
            .form-select,
            .form-select option,
            .form-select optgroup {
                background-color: #0b1220 !important;
                color: #f9fafb !important;
            }
        }

        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: var(--primary-light);
            background: rgba(255, 255, 255, 0.12);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .btn {
            padding: 1rem 2rem;
            border: none;
            border-radius: var(--border-radius);
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            position: relative;
            overflow: hidden;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary), var(--primary-light));
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 3px solid rgba(59, 130, 246, 0.2);
            border-top: 3px solid var(--primary-light);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 1.5rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: var(--text-secondary);
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
        }

        .loading-progress {
            width: 200px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--primary-light));
            width: 0%;
            transition: width 0.5s ease;
        }

        
        .interview-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
        }

        .interview-header {
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--border);
            z-index: 10;
        }

        .interview-title {
            font-weight: 600;
            color: var(--text-primary);
        }

        .interview-controls {
            display: flex;
            gap: 1rem;
            margin-left: auto;
        }

        .control-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .control-btn.active {
            background: var(--primary-light);
        }

        .control-btn.danger {
            background: var(--error);
        }

        .interview-main {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 1rem;
            padding: 1rem;
            overflow: hidden;
            padding-bottom: 96px;
        }

        .main-video {
            background: var(--bg-secondary);
            border-radius: var(--border-radius);
            position: relative;
            overflow: hidden;
            min-height: 400px;
        }

        .avatar-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .video-overlay {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            right: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }

        .participant-info {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            color: white;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .video-status {
            display: flex;
            gap: 0.5rem;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success);
        }

        .status-indicator.muted {
            background: var(--error);
        }

        .sidebar {
            width: 320px;
            background: var(--bg-secondary);
            border-radius: var(--border-radius);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .user-video {
            height: 180px;
            background: var(--bg-tertiary);
            position: relative;
            border-radius: var(--border-radius) var(--border-radius) 0 0;
        }

        .user-video video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .chat-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 1rem;
            overflow: hidden;
            min-height: 0;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 1rem;
            max-height: 100%;
            scrollbar-width: thin;
        }

        .message {
            margin-bottom: 1rem;
            padding: 0.75rem;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
        }

        .message.ai {
            border-left: 3px solid var(--primary-light);
        }

        .message.user {
            border-left: 3px solid var(--success);
        }

        .message-author {
            font-weight: 600;
            font-size: 0.85rem;
            margin-bottom: 0.25rem;
            color: var(--text-secondary);
        }

        .message-content {
            color: var(--text-primary);
            line-height: 1.4;
        }

        .chat-input-container {
            display: flex;
            gap: 0.5rem;
        }

        .chat-input {
            flex: 1;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 8px;
            color: var(--text-primary);
            resize: none;
            min-height: 40px;
            max-height: 100px;
        }

        .send-btn {
            width: 40px;
            height: 40px;
            background: var(--primary-light);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
        }

        .send-btn:hover {
            background: var(--primary);
        }

        
        .push-to-talk-container {
            position: relative;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .push-to-talk-btn {
            width: 56px;
            height: 56px;
            border: 3px solid var(--primary-light);
            border-radius: 50%;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
            font-size: 1.3rem;
            position: relative;
        }

        .push-to-talk-btn:hover {
            background: rgba(59, 130, 246, 0.1);
            border-color: var(--primary);
        }

        .push-to-talk-btn.recording {
            background: var(--error);
            border-color: var(--error);
            color: white;
            animation: pulse-recording 1.5s infinite;
        }

        @keyframes pulse-recording {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .push-to-talk-hint {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-left: 0.5rem;
        }

        
        .speech-status {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-size: 0.8rem;
            white-space: nowrap;
            margin-bottom: 0.5rem;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .speech-status.visible {
            opacity: 1;
        }

        
        .interview-footer {
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            border-top: 1px solid var(--border);
        }

        .footer-controls {
            display: flex;
            gap: 1rem;
        }

        .footer-btn {
            width: 48px;
            height: 48px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
            font-size: 1.2rem;
        }

        .footer-btn.mic {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .footer-btn.mic.muted {
            background: var(--error);
            color: white;
        }

        .footer-btn.camera {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .footer-btn.camera.off {
            background: var(--error);
            color: white;
        }

        .footer-btn.end-call {
            background: var(--error);
            color: white;
        }

        .footer-btn.subtitles {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .footer-btn.subtitles.active {
            background: var(--primary-light);
            color: white;
        }

        
        @media (max-width: 768px) {
            .setup-card {
                padding: 2rem;
                margin: 1rem;
            }

            .setup-title {
                font-size: 2rem;
            }

            .interview-main {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto;
                padding-bottom: 108px;
            }

            .main-video {
                min-height: 260px;
                height: 55vh;
            }

            .sidebar {
                width: 100%;
                height: auto;
                max-height: calc(45vh - 8px);
                display: grid;
                grid-template-columns: 180px 1fr;
            }

            .user-video {
                width: 200px;
                height: 100%;
                border-radius: var(--border-radius) 0 0 var(--border-radius);
                flex-shrink: 0;
            }

            .chat-section {
                min-height: 140px;
                overflow: hidden;
            }

            .chat-messages {
                max-height: calc(45vh - 60px);
                overflow-y: auto;
            }

            .subtitles-overlay {
                bottom: 96px;
                font-size: 0.9rem;
                max-width: 92%;
            }
        }

        @media (max-width: 480px) {
            .sidebar {
                grid-template-columns: 140px 1fr;
            }

            .main-video {
                min-height: 240px;
                height: 52vh;
            }
        }

        
        .floating-ptt {
            position: fixed;
            right: 16px;
            bottom: 88px;
            z-index: 1100;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            pointer-events: none;
        }

        .floating-ptt .push-to-talk-container {
            pointer-events: auto;
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 8px 10px;
            border-radius: 14px;
            backdrop-filter: blur(8px);
        }

        @media (max-width: 768px) {
            .floating-ptt {
                bottom: 96px;
                right: 12px;
            }
        }
    </style>
    <script type="importmap">
    { 
      "imports": { 
        "three": "https://unpkg.com/three@0.149.0/build/three.module.js", 
        "three/addons/": "https://unpkg.com/three@0.149.0/examples/jsm/",
        "lipsync-en": "https://cdn.jsdelivr.net/gh/met4citizen/TalkingHead@1.2/modules/lipsync-en.mjs"
      } 
    }
    </script>
</head>
<body>
    
    <div id="setup-screen" class="setup-container">
        <div class="setup-card fade-in">
            <div class="setup-header">
                <div class="setup-logo">
                    <svg width="32" height="32" viewBox="0 0 24 24" fill="white">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                    </svg>
                </div>
                <h1 class="setup-title">AI Video Interview</h1>
                <p class="setup-subtitle">Practice with our AI interviewer and get instant feedback on your performance</p>
            </div>

            <form id="setup-form" class="form-grid">
                <div class="form-group">
                    <label class="form-label" for="specialization">Target Role</label>
                    <div class="select-wrapper">
                        <select id="specialization" class="form-select">
                            <optgroup label="CA & Accounting (Recommended)">
                                <option value="Chartered Accountant - Audit" selected>Chartered Accountant â€” Audit</option>
                                <option value="Chartered Accountant - Taxation">Chartered Accountant â€” Taxation</option>
                                <option value="Management Accountant (CMA)">Management Accountant (CMA)</option>
                                <option value="Financial Controller">Financial Controller</option>
                                <option value="Statutory Auditor">Statutory Auditor</option>
                                <option value="IFRS Specialist">IFRS Specialist</option>
                                <option value="GST/Indirect Tax Specialist">GST / Indirect Tax Specialist</option>
                                <option value="Direct Tax Consultant">Direct Tax Consultant</option>
                                <option value="Risk & Compliance (SOX/ICFR)">Risk & Compliance (SOX / ICFR)</option>
                                <option value="Treasury Analyst">Treasury Analyst</option>
                                <option value="Corporate Finance Associate">Corporate Finance Associate</option>
                                <option value="Forensic Accountant">Forensic Accountant</option>
                            </optgroup>
                            <optgroup label="Other Roles">
                                <option value="Finance Analyst">Finance Analyst</option>
                                <option value="Business Analyst">Business Analyst</option>
                                <option value="Product Manager">Product Manager</option>
                                <option value="Data Scientist">Data Scientist</option>
                                <option value="Software Engineer">Software Engineer</option>
                                <option value="UX Designer">UX Designer</option>
                                <option value="Marketing Manager">Marketing Manager</option>
                                <option value="Sales Representative">Sales Representative</option>
                            </optgroup>
                        </select>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label" for="experience-level">Experience Level</label>
                    <div class="select-wrapper">
                        <select id="experience-level" class="form-select">
                            <option value="Article/Intern">Article/Intern</option>
                            <option value="Entry Level" selected>Entry Level (0-2 years)</option>
                            <option value="Mid Level">Mid Level (3-5 years)</option>
                            <option value="Senior Level">Senior Level (6-10 years)</option>
                            <option value="Executive Level">Executive Level (10+ years)</option>
                        </select>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label" for="company-type">Company Type</label>
                    <div class="select-wrapper">
                        <select id="company-type" class="form-select">
                            <option value="Big 4 (Audit/Tax)">Big 4 (Audit/Tax)</option>
                            <option value="Mid-size CA Firm">Mid-size CA Firm</option>
                            <option value="Corporate (Industry)">Corporate (Industry)</option>
                            <option value="Consulting Firm">Consulting Firm</option>
                            <option value="Fortune 500">Fortune 500</option>
                            <option value="Tech Startup">Tech Startup</option>
                            <option value="Healthcare">Healthcare</option>
                            <option value="Government">Government</option>
                            <option value="Non-Profit">Non-Profit</option>
                            <option value="Investment Bank">Investment Bank</option>
                        </select>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label" for="interview-duration">Interview Duration</label>
                    <div class="select-wrapper">
                        <select id="interview-duration" class="form-select">
                            <option value="15">15 minutes</option>
                            <option value="30" selected>30 minutes</option>
                            <option value="45">45 minutes</option>
                            <option value="60">60 minutes</option>
                        </select>
                    </div>
                </div>

                <button type="submit" class="btn btn-primary">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M8 5v14l11-7z"/>
                    </svg>
                    Start Interview
                </button>
            </form>
        </div>
    </div>

    
    <div id="loading-screen" class="loading-screen hidden">
        <div class="loading-spinner"></div>
        <div class="loading-text">Preparing your interview...</div>
        <div class="loading-progress">
            <div class="loading-progress-bar" id="loading-progress-bar"></div>
        </div>
    </div>

    
    <div id="permissions-modal" class="permissions-modal hidden">
        <div class="permissions-content">
            <h2 class="permissions-title">Camera & Microphone Access</h2>
            <p class="permissions-text">
                To provide the best interview experience, we need access to your camera and microphone. 
                This helps our AI interviewer analyze your verbal and non-verbal communication.
            </p>
            <div class="permissions-actions">
                <button id="allow-permissions" class="btn btn-primary">Allow Access</button>
                <button id="skip-permissions" class="btn" style="background: var(--bg-tertiary); color: var(--text-primary);">Skip for now</button>
            </div>
        </div>
    </div>

    
    <div id="interview-screen" class="interview-container hidden">
        <header class="interview-header">
            <div class="interview-title">
                AI Video Interview - <span id="current-role">Software Engineer</span>
                <span class="pills">
                    <span id="score-pill" class="pill success">Avg Score: â€”</span>
                    <span id="progress-pill" class="pill info">Progress: 0%</span>
                </span>
            </div>
            <div class="interview-controls">
            </div>
        </header>

        <main class="interview-main">
            <div class="main-video">
                <div id="avatar-container" class="avatar-container">
                    <div id="model-loading-overlay" class="model-loading-overlay">
                        <div class="loading-spinner"></div>
                        <div style="color: var(--text-secondary); margin-top: 1rem;">Loading AI Interviewer...</div>
                    </div>
                </div>
                <div class="video-overlay">
                    <div class="participant-info">
                        Alex Johnson - AI Interviewer
                    </div>
                    <div class="video-status">
                        <div class="status-indicator" id="ai-audio-status"></div>
                    </div>
                </div>
                <div id="subtitles-overlay" class="subtitles-overlay hidden"></div>
            </div>

            <aside class="sidebar">
                <div class="user-video">
                    <video id="user-video" autoplay muted playsinline></video>
                    <div class="video-overlay" style="bottom: 0.5rem; left: 0.5rem; right: 0.5rem;">
                        <div class="participant-info" style="font-size: 0.8rem;">
                            You
                        </div>
                        <div class="video-status">
                            <div class="status-indicator" id="user-audio-status"></div>
                        </div>
                    </div>
                </div>

                <div class="chat-section">
                    <div id="chat-messages" class="chat-messages"></div>
                </div>
            </aside>
        </main>

        <footer class="interview-footer">
            <div class="footer-controls">
                <button id="subtitles-btn" class="footer-btn subtitles" title="Toggle Subtitles">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19 4H5c-1.66 0-3.15.25-4.6.72v3.1c0 .39-.23.74-.56.9-.98.49-1.87 1.12-2.66 1.85-.18.18-.43.28-.7.28-.28 0-.53-.11-.71-.29L.29 13.08c-.18-.17-.29-.42-.29-.7 0-.28.11-.53.29-.71C3.34 8.78 7.46 7 12 7s8.66 1.78 11.71 4.67c.18.18.29.43.29.71 0 .28-.11.53-.29.71l-2.48 2.48c-.18.18-.43.29-.71.29-.79-.73-1.68-1.36-2.66-1.85-.33-.16-.56-.51-.56-.9v-3.1C15.15 9.25 13.6 9 12 9z"/>
                    </svg>
                </button>
                <button id="end-call-btn" class="footer-btn end-call" title="End Interview">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 9c-1.66 0-3.15.25-4.6.72v3.1c0 .39-.23.74-.56.9-.98.49-1.87 1.12-2.66 1.85-.18.18-.43.28-.7.28-.28 0-.53-.11-.71-.29L.29 13.08c-.18-.17-.29-.42-.29-.7 0-.28.11-.53.29-.71C3.34 8.78 7.46 7 12 7s8.66 1.78 11.71 4.67c.18.18.29.43.29.71 0 .28-.11.53-.29.71l-2.48 2.48c-.18.18-.43.29-.71.29-.79-.73-1.68-1.36-2.66-1.85-.33-.16-.56-.51-.56-.9v-3.1C15.15 9.25 13.6 9 12 9z"/>
                    </svg>
                </button>
            </div>
        </footer>

        
        <div class="floating-ptt" aria-live="polite">
            <div class="push-to-talk-container">
                <button id="push-to-talk-btn" class="push-to-talk-btn" title="Hold to speak" aria-label="Hold to speak">
                    <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                        <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.49 6-3.31 6-6.72h-1.7z"/>
                    </svg>
                </button>
                <div id="speech-status" class="speech-status" role="status" aria-live="polite"></div>
                <span class="push-to-talk-hint">Hold to speak, release to send</span>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { LipsyncEn } from 'lipsync-en';

        class TalkingHead {
            constructor(node, opt = {}) {
                this.nodeAvatar = node;
                this.opt = { ttsEndpoint: null, lipsyncLang: 'en', cameraView: 'upper', ...opt };
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                const w = Math.max( this.nodeAvatar.clientWidth || 640, 640 );
                const h = Math.max( this.nodeAvatar.clientHeight || 360, 360 );
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.setSize(w, h);
                this.renderer.outputColorSpace = THREE.SRGBColorSpace;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.sortObjects = false;
                this.nodeAvatar.appendChild(this.renderer.domElement);
                this.camera = new THREE.PerspectiveCamera(25, w / h, 0.1, 100);
                this.scene = new THREE.Scene();
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.8));
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                directionalLight.position.set(0.5, 1, 1).normalize();
                this.scene.add(directionalLight);
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableZoom = false; 
                this.controls.enablePan = false; 
                this.controls.target.set(0, 1.6, 0);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.animClock = 0; this.animTimeLast = 0;
                this.avatar = null; this.armature = null; this.morphs = []; this.mixer = null;
                this.speechQueue = []; this.isSpeaking = false; this.isRunning = false; this.stateName = 'idle';
                this.audioCtx = new AudioContext(); this.audioSpeechSource = null;
                this.lipsync = {};
                this.visemeNames = [ 'viseme_sil', 'viseme_PP', 'viseme_FF', 'viseme_TH', 'viseme_DD', 'viseme_kk', 'viseme_CH', 'viseme_SS', 'viseme_nn', 'viseme_RR', 'viseme_aa', 'viseme_E', 'viseme_I', 'viseme_O', 'viseme_U' ];
                this.poseTemplates = { 
                    'side': {
                        standing: true,
                        props: {
                            'Hips.position': { x: 0, y: 1, z: 0 },
                            'Hips.rotation': { x: -0.003, y: -0.017, z: 0.1 },
                            'Spine.rotation': { x: -0.103, y: -0.002, z: -0.063 },
                            'Spine1.rotation': { x: 0.042, y: -0.02, z: -0.069 },
                            'Spine2.rotation': { x: 0.131, y: -0.012, z: -0.065 },
                            'Neck.rotation': { x: 0.027, y: 0.006, z: 0 },
                            'Head.rotation': { x: 0.077, y: -0.065, z: 0 },
                            'LeftShoulder.rotation': { x: 1.599, y: 0.084, z: -1.77 },
                            'LeftArm.rotation': { x: 1.364, y: 0.052, z: -0.044 },
                            'LeftForeArm.rotation': { x: 0.002, y: -0.007, z: 0.331 },
                            'LeftHand.rotation': { x: 0.104, y: -0.067, z: -0.174 },
                            'LeftUpLeg.rotation': { x: 0.096, y: 0.209, z: 2.983 },
                            'LeftLeg.rotation': { x: -0.053, y: 0.042, z: -0.017 },
                            'LeftFoot.rotation': { x: 1.091, y: 0.15, z: 0.026 },
                            'RightShoulder.rotation': { x: 1.541, y: 0.192, z: 1.775 },
                            'RightArm.rotation': { x: 1.273, y: -0.352, z: -0.067 },
                            'RightForeArm.rotation': { x: -0.011, y: -0.031, z: -0.357 },
                            'RightHand.rotation': { x: -0.008, y: 0.312, z: -0.028 },
                            'RightUpLeg.rotation': { x: -0.307, y: -0.219, z: 2.912 },
                            'RightLeg.rotation': { x: -0.359, y: 0.164, z: 0.015 },
                            'RightFoot.rotation': { x: 1.035, y: 0.11, z: 0.005 }
                        }
                    },
                    'straight': {
                        standing: true,
                        props: {
                            'Hips.position': { x: 0, y: 0.989, z: 0.001 },
                            'Hips.rotation': { x: 0.047, y: 0.007, z: -0.007 },
                            'Spine.rotation': { x: -0.143, y: -0.007, z: 0.005 },
                            'Spine1.rotation': { x: -0.043, y: -0.014, z: 0.012 },
                            'Spine2.rotation': { x: 0.072, y: -0.013, z: 0.013 },
                            'Neck.rotation': { x: 0.048, y: -0.003, z: 0.012 },
                            'Head.rotation': { x: 0.05, y: -0.02, z: -0.017 },
                            'LeftShoulder.rotation': { x: 1.62, y: -0.166, z: -1.605 },
                            'LeftArm.rotation': { x: 1.275, y: 0.544, z: -0.092 },
                            'LeftForeArm.rotation': { x: 0, y: 0, z: 0.302 },
                            'LeftHand.rotation': { x: -0.225, y: -0.154, z: 0.11 },
                            'RightShoulder.rotation': { x: 1.615, y: 0.064, z: 1.53 },
                            'RightArm.rotation': { x: 1.313, y: -0.424, z: 0.131 },
                            'RightForeArm.rotation': { x: 0, y: 0, z: -0.317 },
                            'RightHand.rotation': { x: -0.158, y: -0.639, z: -0.196 },
                            'LeftUpLeg.rotation': { x: -0.077, y: -0.058, z: 3.126 },
                            'LeftLeg.rotation': { x: -0.252, y: 0.001, z: -0.018 },
                            'LeftFoot.rotation': { x: 1.315, y: -0.064, z: 0.315 },
                            'RightUpLeg.rotation': { x: -0.083, y: -0.032, z: 3.124 },
                            'RightLeg.rotation': { x: -0.272, y: -0.003, z: 0.021 },
                            'RightFoot.rotation': { x: 1.342, y: 0.076, z: -0.222 }
                        }
                    }
                };
                this.animMoods = {
                    neutral: {
                        anims: [
                            {
                                name: 'breathing',
                                loop: -1,
                                delay: 1500,
                                dt: [1200, 500, 1000],
                                vs: { chestInhale: [0.5, 0.5, 0] }
                            },
                            {
                                name: 'pose',
                                loop: -1,
                                alt: [
                                    {
                                        p: 0.4,
                                        delay: [5000, 20000],
                                        dt: [2000],
                                        vs: { pose: ['side'] }
                                    },
                                    {
                                        delay: [5000, 20000],
                                        dt: [2000],
                                        vs: { pose: ['straight'] }
                                    }
                                ]
                            },
                            {
                                name: 'head',
                                loop: -1,
                                idle: {
                                    delay: [0, 1000],
                                    dt: [[200, 5000]],
                                    vs: {
                                        headRotateX: [[-0.04, 0.10]],
                                        headRotateY: [[-0.3, 0.3]],
                                        headRotateZ: [[-0.08, 0.08]]
                                    }
                                },
                                talking: {
                                    delay: [0, 1000],
                                    dt: [[0, 1000, 0]],
                                    vs: {
                                        headRotateX: [[-0.05, 0.15, 1, 2]],
                                        headRotateY: [[-0.1, 0.1]],
                                        headRotateZ: [[-0.1, 0.1]]
                                    }
                                }
                            },
                            {
                                name: 'eyes',
                                loop: -1,
                                delay: [200, 5000],
                                dt: [[100, 500], [100, 5000, 2]],
                                vs: {
                                    eyesRotateY: [[-0.6, 0.6]],
                                    eyesRotateX: [[-0.2, 0.6]]
                                }
                            },
                            {
                                name: 'blink',
                                loop: -1,
                                delay: [1000, 8000],
                                dt: [50, [100, 300], 100],
                                vs: {
                                    eyeBlinkLeft: [1, 1, 0],
                                    eyeBlinkRight: [1, 1, 0]
                                }
                            },
                            {
                                name: 'mouth',
                                loop: -1,
                                delay: [1000, 5000],
                                dt: [[100, 500], [100, 5000, 2]],
                                vs: {
                                    mouthRollLower: [[0, 0.3, 2]],
                                    mouthPucker: [[0, 0.3]]
                                }
                            }
                        ]
                    }
                };

                this.animEmojis = {
                    'ðŸ˜Š': { name: 'smile', dt: [300, 1000], vs: { mouthSmile: [0.7], eyeSquintLeft: [0.8], eyeSquintRight: [0.8] } },
                    'ðŸ˜‰': { name: 'wink', dt: [100, 200, 500], vs: { mouthSmile: [0.5, 0.5, 0], eyeBlinkRight: [1, 1, 0] } },
                    'ðŸ˜ž': { name: 'sad', dt: [1000], vs: { browInnerUp: [0.7], mouthFrownLeft: [0.8], mouthFrownRight: [0.8] } },
                    'ðŸ˜¡': { name: 'angry', dt: [500], vs: { browDownLeft: [1], browDownRight: [1], mouthFrownLeft: [1], mouthFrownRight: [1] } }
                };

                this.animQueue = [];
                this.easing = t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
                this.poseBase = {}; this.poseTarget = {}; this.poseAvatar = {}; this.poseDelta = { props: {} };
                this.poseWeightOnLeft = true;
                this.randomized = ['mouthStretchLeft', 'mouthStretchRight', 'mouthRollLower', 'mouthRollUpper', 'browDownLeft', 'browDownRight', 'browOuterUpLeft', 'browOuterUpRight', 'cheekPuff', 'cheekSquintLeft', 'cheekSquintRight'];
                this.animBaseline = {};
                this.ikMesh = new THREE.SkinnedMesh();
                window.addEventListener('resize', this.onResize.bind(this));
                this.envLoaded = false;
            }

            init() {
                this.lipsync[this.opt.lipsyncLang] = new LipsyncEn();
                const rgbe = new RGBELoader();
                const hdrUrl = 'https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/2k/studio_small_09_2k.hdr';
                rgbe.load(hdrUrl, (tex) => {
                    tex.mapping = THREE.EquirectangularReflectionMapping;
                    this.scene.environment = tex;
                    this.scene.background = tex;
                    this.envLoaded = true;
                }, undefined, (e) => {
                    console.warn('HDR env load failed', e);
                    this.scene.background = new THREE.Color(0x0f172a);
                });
            }

            fixMaterial(mat, owner) {
                if (!mat) return;
                const ownerName = (owner?.name || '').toLowerCase();
                const matName = (mat.name || '').toLowerCase();
                const tag = (ownerName + ' ' + matName);

                const isHairCard = /(hair|lash|eyelash|eyebrow|brow|beard|stubble|mustache)/i.test(tag);
                const isEyeCornea = /(cornea|eyemoisture|tear|tearline|eye_moisture|eye\-moisture)/i.test(tag);
                const isEyeIrisSclera = /(eye$|eyes$|iris|sclera|eyeball)/i.test(tag) && !isEyeCornea;

                const makeOpaqueSolid = (m) => {
                    m.transparent = false;
                    m.alphaTest = 0;
                    m.opacity = 1;
                    m.depthWrite = true;
                    m.depthTest = true;
                    m.blending = THREE.NormalBlending;
                    m.side = THREE.FrontSide;
                    m.needsUpdate = true;
                };

                if (isEyeCornea) {
                    mat.transparent = true;
                    mat.alphaTest = 0.0;
                    mat.opacity = Math.min(1, Math.max(0.2, mat.opacity ?? 0.35));
                    mat.depthWrite = false;
                    mat.depthTest = true;
                    mat.blending = THREE.NormalBlending;
                    mat.side = THREE.FrontSide;
                    mat.polygonOffset = true;
                    mat.polygonOffsetFactor = -0.5;
                    mat.polygonOffsetUnits = -1;
                    mat.needsUpdate = true;
                    return;
                }

                if (isHairCard) {
                    mat.alphaTest = Math.max(mat.alphaTest || 0, 0.5);
                    mat.transparent = false;
                    mat.opacity = 1;
                    mat.depthWrite = true;
                    mat.depthTest = true;
                    mat.blending = THREE.NormalBlending;
                    mat.side = THREE.FrontSide;
                    mat.polygonOffset = true;
                    mat.polygonOffsetFactor = 0.5;
                    mat.polygonOffsetUnits = 1;
                    mat.needsUpdate = true;
                    return;
                }

                if (isEyeIrisSclera) {
                    makeOpaqueSolid(mat);
                    mat.polygonOffset = true;
                    mat.polygonOffsetFactor = 0.25;
                    mat.polygonOffsetUnits = 0.5;
                    return;
                }

                const hasRGBA = !!(mat.map && mat.map.format === THREE.RGBAFormat);
                const looksTransparent = mat.transparent || (mat.opacity !== undefined && mat.opacity < 1) || hasRGBA;
                if (looksTransparent) {
                    mat.alphaTest = Math.max(mat.alphaTest || 0, 0.5);
                    mat.transparent = false;
                    mat.opacity = 1;
                    mat.depthWrite = true;
                    mat.depthTest = true;
                    mat.blending = THREE.NormalBlending;
                    mat.side = THREE.FrontSide;
                    mat.needsUpdate = true;
                } else {
                    makeOpaqueSolid(mat);
                }
            }

            async showAvatar(avatar) {
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync(avatar.url);
                this.armature = gltf.scene;

                this.armature.traverse(node => {
                    if (node.isMesh || node.isSkinnedMesh) {
                        if (Array.isArray(node.material)) {
                            node.material = node.material.map(m => m.clone());
                            node.material.forEach(m => this.fixMaterial(m, node));
                        } else if (node.material) {
                            node.material = node.material.clone();
                            this.fixMaterial(node.material, node);
                        }

                        if (node.material) {
                            if (Array.isArray(node.material)) {
                                node.material.forEach(m => { m.envMap = null; });
                            } else {
                                node.material.envMap = null;
                            }
                        }

                        const n = (node.name || '').toLowerCase();
                        if (/(cornea|eyemoisture|tear|tearline|eye_moisture|eye\-moisture)/i.test(n)) {
                            node.renderOrder = 30; 
                        } else if (/(eye$|eyes$|iris|sclera|eyeball)/i.test(n)) {
                            node.renderOrder = 20;
                        } else if (/(lash|eyelash|brow|eyebrow)/i.test(n)) {
                            node.renderOrder = 15;
                        } else {
                            node.renderOrder = 10;
                        }

                        if (node.morphTargetDictionary) { this.morphs.push(node); }
                        node.frustumCulled = false;
                    }
                });

                if (!this.morphs.length) { throw new Error("No morph targets found on model."); }
                
                this.poseBase = this.poseFactory(this.poseTemplates.straight);
                this.poseTarget = this.poseFactory(this.poseTemplates.straight);
                this.poseAvatar.props = {};
                this.poseDelta.props = {};

                const posePropNames = new Set();
                Object.values(this.poseTemplates).forEach(x => {
                    Object.keys(this.propsToThreeObjects(x.props)).forEach(y => posePropNames.add(y));
                });

                for (const key of posePropNames) {
                    const [boneName, propName] = key.split('.');
                    const bone = this.armature.getObjectByName(boneName);
                    if (bone && bone[propName]) {
                        this.poseAvatar.props[key] = bone[propName];
                        if(this.poseBase.props[key]) {
                            this.poseAvatar.props[key].copy(this.poseBase.props[key]);
                        } else {
                            this.poseBase.props[key] = this.poseAvatar.props[key].clone();
                        }
                        if(this.poseTarget.props[key]) {
                            this.poseTarget.props[key].t = this.animClock;
                            this.poseTarget.props[key].d = 2000;
                        }
                         if(propName === 'quaternion' || propName === 'scale') {
                             this.poseDelta.props[key] = propName === 'quaternion' ? new THREE.Euler() : new THREE.Vector3();
                        }
                    }
                }

                this.mixer = new THREE.AnimationMixer(this.armature);
                let idleClip = gltf.animations.find(clip => clip.name.toLowerCase() === 'idle') || gltf.animations[0];
                if(idleClip) { this.mixer.clipAction(idleClip).play(); }
                
                this.scene.add(this.armature);
                this.setView(this.opt.cameraView);
                this.start();
            }

            propsToThreeObjects(p) { const r = {}; for (let [key, val] of Object.entries(p)) { const ids = key.split('.'); let v; let x = val.x ?? 0; let y = val.y ?? 0; let z = val.z ?? 0; if (ids[1] === 'position' || ids[1] === 'scale') { v = new THREE.Vector3(x, y, z); } else if (ids[1] === 'rotation') { key = ids[0] + '.quaternion'; v = new THREE.Quaternion().setFromEuler(new THREE.Euler(x, y, z, 'XYZ')); } if (v) r[key] = v; } return r; }
            poseFactory(template, ms = 2000) { const o = { template: template, props: this.propsToThreeObjects(template.props) }; for (const v of Object.values(o.props)) { v.t = this.animClock; v.d = ms; } return o; }
            mirrorPose(p) { const r = {}; for (let [key, v] of Object.entries(p)) { if (v.isQuaternion) { if (key.startsWith('Left')) { key = 'Right' + key.substring(4); } else if (key.startsWith('Right')) { key = 'Left' + key.substring(5); } v.x *= -1; v.w *= -1; } r[key] = v.clone(); r[key].t = v.t; r[key].d = v.d; } return r; }
            setPoseFromTemplate(templateName, ms=2000) { 
                const template = this.poseTemplates[templateName]; 
                if(!template) return;
                const isSameTemplate = this.poseCurrentTemplate && template.props === this.poseCurrentTemplate.props;
                this.poseBase = this.poseFactory(this.poseCurrentTemplate || this.poseTemplates.straight, ms); 
                this.poseTarget = this.poseFactory(template, ms);
                this.poseCurrentTemplate = template;
                
                if ((!isSameTemplate && !this.poseWeightOnLeft) || (isSameTemplate && this.poseWeightOnLeft)) {
                    this.poseTarget.props = this.mirrorPose(this.poseTarget.props);
                    this.poseWeightOnLeft = !this.poseWeightOnLeft;
                }
            }

            startIdleAnimations() { this.animMoods.neutral.anims.forEach(animTemplate => { this.animQueue.push(this.animFactory(animTemplate)); }); }
            stopIdleAnimations() { this.animQueue = this.animQueue.filter(anim => anim.loop !== -1 && anim.template.name !== 'pose'); }
            animFactory(t) { 
                const o = { template: t, ts: [0], vs: {}, loop: t.loop }; 
                let a = t;
                if (a[this.stateName]) {
                    a = a[this.stateName];
                }
                if (a.alt) {
                    let b = a.alt[0];
                    if (a.alt.length > 1) {
                        const coin = Math.random(); 
                        let p = 0; 
                        for (let i = 0; i < a.alt.length; i++) {
                            p += a.alt[i].p || (1 - p) / (a.alt.length - i); 
                            if (coin < p) { 
                                b = a.alt[i]; 
                                break; 
                            } 
                        }
                    }
                    a = b;
                }

                const delay = a.delay ? (Array.isArray(a.delay) ? this.gaussianRandom(...a.delay) : a.delay) : 0;
                const dt = a.dt || t.dt;
                dt.forEach((x, i) => o.ts[i + 1] = o.ts[i] + (Array.isArray(x) ? this.gaussianRandom(...x) : x));
                o.ts = o.ts.map(x => this.animClock + delay + x);
                const vs = a.vs || t.vs;
                Object.entries(vs).forEach(([mt, v_seq]) => { 
                    o.vs[mt] = [null, ...v_seq.map(x => Array.isArray(x) ? this.gaussianRandom(...x) : x)]; 
                    while (o.vs[mt].length - 1 < o.ts.length) o.vs[mt].push(o.vs[mt].at(-1)); 
                });
                return o;
            }
            gaussianRandom(start, end, skew=1, samples=3) { let r = 0; for(let i=0; i<samples; i++) r += Math.random(); return start + Math.pow(r/samples,skew) * (end - start); }
            setView(view) { let z = 2.5; if (view === 'head') z = 1.2; this.camera.position.set(0, 1.6, z); this.controls.update(); }
            onResize() { this.camera.aspect = this.nodeAvatar.clientWidth / this.nodeAvatar.clientHeight; this.camera.updateProjectionMatrix(); this.renderer.setSize(this.nodeAvatar.clientWidth, this.nodeAvatar.clientHeight); }
            start() { if (this.isRunning) return; this.isRunning = true; this.animTimeLast = performance.now(); this.startIdleAnimations(); this.renderer.setAnimationLoop(this.animate.bind(this)); }
            
            animate() {
                const now = performance.now(); const dt = now - this.animTimeLast; this.animClock += dt; this.animTimeLast = now;
                if (this.mixer) this.mixer.update(dt / 1000);
                this.controls.update();

                if (Math.random() < 0.1) {
                    const randomizedMs = this.randomized[Math.floor(Math.random() * this.randomized.length)];
                    const v = this.getValue(randomizedMs);
                    const vb = this.getBaselineValue(randomizedMs);
                    if (Math.abs(v - vb) < 0.01) {
                        const randomizedV = (this.mood?.baseline?.[randomizedMs] || 0) + Math.random() / 5;
                        this.setBaselineValue(randomizedMs, randomizedV);
                    }
                }

                const frameMorphAcc = new Map();
                 for (let [mt, x] of Object.entries(this.animBaseline)) {
                    const v = this.getValue(mt);
                    const restrain = (this.isSpeaking && mt.startsWith("mouth")) ? 3 : 1;
                    const target = x.target / restrain;
                    if (Math.abs(v - target) > 0.01) {
                        if (x.t0 === undefined) {
                            x.t0 = this.animClock;
                            x.v0 = v;
                        }
                        let delay = 1000;
                        const val = this.valueAnimationSeq([x.t0, x.t0 + delay], [x.v0, target], this.animClock);
                        frameMorphAcc.set(mt, val);
                    } else {
                        x.t0 = undefined;
                        frameMorphAcc.set(mt, target);
                    }
                }

                this.updatePoseBase();

                for (let i = 0; i < this.animQueue.length; i++) {
                    const anim = this.animQueue[i];
                    if (this.animClock >= anim.ts[0]) {
                        Object.entries(anim.vs).forEach(([mt, vs]) => { 
                            if (mt === 'pose' && this.animClock >= anim.ts[1]) { this.setPoseFromTemplate(vs[1]); anim.ts = [Infinity]; return; }
                            if (vs[0] === null) vs[0] = this.getValue(mt);
                            const vv = this.valueAnimationSeq(anim.ts, vs, this.animClock);
                            const prev = frameMorphAcc.get(mt) ?? -Infinity;
                            if (vv > prev) frameMorphAcc.set(mt, vv);
                        });
                        if (this.animClock >= anim.ts.at(-1)) {
                            if (anim.loop === -1) {
                                 if (this.stateName === 'idle' || (this.stateName === 'talking' && (anim.template.name === 'head' || anim.template.name === 'eyes')) ) {
                                    const restrain = (this.stateName === 'talking' && (anim.template.name === 'head' || anim.template.name === 'eyes')) ? 4 : 1;
                                    this.animQueue[i] = this.animFactory(anim.template, anim.loop, 1, 1 / restrain);
                                } else {
                                    this.animQueue.splice(i--, 1);
                                }
                            } else {
                                this.animQueue.splice(i--, 1);
                            }
                        }
                    }
                }
                this.updatePoseDelta(frameMorphAcc);
                for (const mesh of this.morphs) {
                    for (const name in mesh.morphTargetDictionary) {
                        const idx = mesh.morphTargetDictionary[name];
                        const value = frameMorphAcc.get(name);
                        if (value !== undefined && typeof value === 'number' && !isNaN(value)) {
                            mesh.morphTargetInfluences[idx] = Math.min(1, Math.max(0, value));
                        } else if (!this.isViseme(name)) {
                            const current = mesh.morphTargetInfluences[idx] || 0;
                            if (current > 0.001) {
                                mesh.morphTargetInfluences[idx] = Math.max(0, current * 0.95);
                            } else {
                                mesh.morphTargetInfluences[idx] = 0;
                            }
                        }
                    }
                }

                const box = new THREE.Box3();
                box.setFromObject(this.armature);
                const ltoePos = new THREE.Vector3();
                const rtoePos = new THREE.Vector3();
                this.armature.getObjectByName('LeftToeBase').getWorldPosition(ltoePos);
                this.armature.getObjectByName('RightToeBase').getWorldPosition(rtoePos);
                const hips = this.armature.getObjectByName('Hips');
                if (hips) {
                    hips.position.y -= box.min.y / 2;
                    hips.position.x -= (ltoePos.x + rtoePos.x) / 4;
                    hips.position.z -= (ltoePos.z + rtoePos.z) / 2;
                }

                this.renderer.render(this.scene, this.camera);
            }

            updatePoseBase() { for (const [key, v] of Object.entries(this.poseTarget.props)) { const o = this.poseAvatar.props[key]; if (!o || !this.poseBase.props[key]) continue; const alpha = Math.min(1, (this.animClock - v.t) / v.d); if (alpha > 1 || !this.poseBase.props.hasOwnProperty(key)) { o.copy(v); } else if (o.isQuaternion) { o.copy(this.poseBase.props[key]).slerp(v, this.easing(alpha)); } else if (o.isVector3) { o.copy(this.poseBase.props[key]).lerp(v, this.easing(alpha)); } } }
            updatePoseDelta(morphs) { const euler = this.poseDelta.props['Head.quaternion']; if(euler) euler.set(morphs.get('headRotateX')||0, morphs.get('headRotateY')||0, morphs.get('headRotateZ')||0); const q = new THREE.Quaternion().setFromEuler(euler || new THREE.Euler()); if(this.poseAvatar.props['Head.quaternion']) this.poseAvatar.props['Head.quaternion'].multiply(q); const scale = morphs.get('chestInhale')||0; if(this.poseAvatar.props['Spine1.scale']) { const s = 1 + scale; this.poseAvatar.props['Spine1.scale'].set(s,s,s); } }
            
            valueAnimationSeq(ts, vs, t) {
                if (!ts || ts.length < 2) return 0;
                if (t <= ts[0]) return vs[1];
                if (t >= ts.at(-1)) return vs.at(-1);
                let i = 0;
                for (i = 0; i < ts.length - 2; i++) {
                    if (t >= ts[i] && t < ts[i+1]) { break; }
                }
                const startTime = ts[i]; const endTime = ts[i+1];
                const startValue = vs[i+1]; const endValue = vs[i+2];
                if (endTime === startTime) return startValue;
                const progress = (t - startTime) / (endTime - startTime);
                return startValue + (endValue - startValue) * this.easing(progress);
            }

            isViseme(name) { return name.startsWith('viseme_'); }
            
            getBaselineValue(mt) { return (this.animBaseline.hasOwnProperty(mt) ? this.animBaseline[mt].target : 0); }
            setBaselineValue(mt, v) {
                if (v === null) {
                    if (this.animBaseline.hasOwnProperty(mt)) delete this.animBaseline[mt];
                } else {
                    this.animBaseline[mt] = { target: v, t0: undefined, v0: 0 };
                }
            }

            getValue(mt) { 
                if (mt.startsWith('headRotate')) {
                    const axis = mt.charAt(mt.length - 1).toLowerCase();
                    return this.poseDelta.props['Head.quaternion']?.[axis] || 0;
                }
                if (mt === 'chestInhale') {
                    return (this.poseDelta.props['Spine1.scale']?.x || 0) * 20;
                }
                const mesh = this.morphs[0]; 
                return (mesh && mesh.morphTargetDictionary[mt] !== undefined) ? mesh.morphTargetInfluences[mesh.morphTargetDictionary[mt]] : 0; 
            }
            
            speakText(text) { 
                if (this.isSpeaking) { 
                    this.speechQueue.push({ type: 'text', content: text }); 
                    return; 
                } 
                this.processSpeechItem({ type: 'text', content: text }); 
            }

            speakEmoji(emojiChar) { 
                this.speechQueue.push({ type: 'emoji', content: this.animEmojis[emojiChar] }); 
                if(!this.isSpeaking) this.startSpeaking(); 
            }

            async processSpeechItem(item) {
                this.isSpeaking = true; this.stateName = 'talking';
                this.stopIdleAnimations();
                this.resetLips();
                
                if (item.type === 'text') {
                    this.speakWithHands(0, 0.5);
                    try {
                        const preprocessedText = this.lipsync.en.preProcessText(sanitizeForTTS(item.content));
                        const response = await fetch(this.opt.ttsEndpoint, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ text: preprocessedText }) });
                        if (!response.ok) throw new Error(`TTS Error: ${response.status} ${await response.text()}`);
                        const data = await response.json();
                        if (!data.audioContent || !data.timepoints) throw new Error("Invalid TTS response format.");
                        await this.playAudioWithVisemes(data.audioContent, data.timepoints);
                    } catch (error) { console.error("TTS failed:", error); this.finishSpeaking(); }
                } else if (item.type === 'emoji') {
                    const anim = this.animFactory(item.content);
                    this.animQueue.push(anim);
                    setTimeout(() => this.finishSpeaking(), anim.ts.at(-1) - this.animClock);
                }
            }

            async playAudioWithVisemes(base64Audio, timepoints) {
                if (this.audioCtx.state === 'suspended') await this.audioCtx.resume();

                const audioData = Uint8Array.from(atob(base64Audio), c => c.charCodeAt(0)).buffer;
                const audioBuffer = await this.audioCtx.decodeAudioData(audioData);

                const LEAD_IN_MS = 80;                
                const MIN_WORD_MS = 220;              
                const MIN_VISEME_MS = 90;             
                const MAX_VISEMES_PER_WORD = 3;       
                const PEAK_FRACTION = 0.45;           
                const AMPLITUDE = 0.6;                

                const audioStartAnimClock = this.animClock + 150;

                const sortedTP = [...timepoints].sort((a, b) => parseInt(a.mark_name) - parseInt(b.mark_name));

                const condenseVisemes = (visemes, times, durations) => {
                    const out = [];
                    for (let i = 0; i < visemes.length; i++) {
                        const v = visemes[i];
                        if (v === 'sil') continue;
                        out.push({ v, t: times[i], d: durations[i] });
                    }
                    if (!out.length) return out;

                    const merged = [];
                    for (const seg of out) {
                        const last = merged[merged.length - 1];
                        if (last && last.v === seg.v) {
                            last.d += seg.d;
                        } else {
                            merged.push({ ...seg });
                        }
                    }

                    if (merged.length > MAX_VISEMES_PER_WORD) {
                        const sortedByDur = [...merged].sort((a, b) => b.d - a.d).slice(0, MAX_VISEMES_PER_WORD);
                        sortedByDur.sort((a, b) => a.t - b.t);
                        return sortedByDur;
                    }

                    return merged;
                };

                sortedTP.forEach((tp, idx) => {
                    const nextTp = sortedTP[idx + 1];
                    const wordStartMs = tp.time_seconds * 1000;
                    const wordEndMs = nextTp
                        ? (nextTp.time_seconds * 1000)
                        : (audioBuffer.duration * 1000);
                    let wordDurationMs = Math.max(MIN_WORD_MS, wordEndMs - wordStartMs);
                    if (wordDurationMs <= 0) return;

                    const visemeData = this.lipsync.en.wordsToVisemes(tp.word);
                    if (!visemeData.visemes.length) return;

                    const condensed = condenseVisemes(
                        visemeData.visemes,
                        visemeData.times,
                        visemeData.durations
                    );
                    if (!condensed.length) return;

                    const totalRel = condensed.reduce((sum, s) => sum + s.d, 0) || 1;

                    for (let i = 0; i < condensed.length; i++) {
                        const { v, t, d } = condensed[i];
                        const visemeName = "viseme_" + v;
                        if (this.morphs[0]?.morphTargetDictionary[visemeName] === undefined) continue;

                        const relStart = t;
                        const relDur = d;
                        const absStart = wordStartMs + (relStart / totalRel) * wordDurationMs;
                        let absDur = (relDur / totalRel) * wordDurationMs;

                        if (absDur < MIN_VISEME_MS) {
                            const extraNeeded = MIN_VISEME_MS - absDur;
                            const remaining = (wordStartMs + wordDurationMs) - (absStart + absDur);
                            const grant = Math.min(remaining, extraNeeded);
                            absDur += Math.max(0, grant);
                            if (absDur < MIN_VISEME_MS * 0.8) continue;
                        }

                        const startTime = audioStartAnimClock + absStart - LEAD_IN_MS;
                        const peakTime = startTime + LEAD_IN_MS + absDur * PEAK_FRACTION;
                        const endTime = startTime + LEAD_IN_MS + absDur;

                        if (endTime - startTime < 50) continue; 

                        this.animQueue.push({
                            ts: [startTime, peakTime, endTime],
                            vs: { [visemeName]: [null, AMPLITUDE, 0] }
                        });
                    }
                });

                if (this.audioSpeechSource) { this.audioSpeechSource.stop(); }
                this.audioSpeechSource = this.audioCtx.createBufferSource();
                this.audioSpeechSource.buffer = audioBuffer;
                this.audioSpeechSource.connect(this.audioCtx.destination);
                const startAt = this.audioCtx.currentTime + 0.150;
                this.audioSpeechSource.start(startAt);
                if (typeof scheduleAISubtitles === 'function') {
                    scheduleAISubtitles(sortedTP, audioBuffer.duration, startAt);
                }
                this.audioSpeechSource.onended = () => this.finishSpeaking();
            }
            
            resetLips() { this.animQueue = this.animQueue.filter(a => !Object.keys(a.vs)[0].startsWith('viseme_')); this.visemeNames.forEach(name => { const current = this.getValue(name); if (current > 0.001) { const now = this.animClock; this.animQueue.push({ ts: [now, now + 60], vs: { [name]: [current, 0] }}); }}); }
            startSpeaking() { if (this.isSpeaking || !this.speechQueue.length) return; this.processSpeechItem(this.speechQueue.shift()); }
            finishSpeaking() { this.isSpeaking = false; this.stateName = 'idle'; this.resetLips(); this.startIdleAnimations(); if (this.speechQueue.length > 0) this.startSpeaking(); }
            stopSpeaking() { if (this.audioSpeechSource) { this.audioSpeechSource.onended = null; this.audioSpeechSource.stop(); this.audioSpeechSource = null; } this.speechQueue = []; this.finishSpeaking(); }
            
            speakWithHands(delay=0, prob=0.5) {
                if (Math.random() > prob) return;

                const dt = [100 + Math.round(Math.random() * 500)];
                const moveto = [{
                    duration: 1000,
                    props: {
                        "LeftHand.rotation": { x: 0, y: -1 - Math.random(), z: 0 },
                        "RightHand.rotation": { x: 0, y: 1 + Math.random(), z: 0 },
                        "LeftArm.rotation": {x: 1.5, y:0, z:0},
                        "RightArm.rotation": {x: 1.5, y:0, z:0},
                        "LeftForeArm.rotation": {x: 0, y:0, z:1},
                        "RightForeArm.rotation": {x: 0, y:0, z:-1},
                    }
                }];

                dt.push(1000 + Math.round(Math.random() * 500));
                moveto.push({ duration: 2000, props: {} });
                ["LeftArm", "LeftForeArm", "RightArm", "RightForeArm", "LeftHand", "RightHand"].forEach(x => {
                    moveto[1].props[x + '.rotation'] = null;
                });

                const anim = this.animFactory({
                    name: 'talkinghands',
                    delay: delay,
                    dt: dt,
                    vs: { moveto: moveto }
                });
                this.animQueue.push(anim);
            }
        }

        let avatar;
        let userStream;
        let isModelLoaded = false;
        let areSubtitlesOn = true; 
        let interviewConfig = {};
        let messages = [];
        let isRecording = false;
        let speechRecognition;
        let isWaitingForAIResponse = false;
        let scores = [];

        const WORKER_URL = 'https://interviewme.bhansalimanan55.workers.dev/';
        const TTS_ENDPOINT = 'https://us-central1-msc-notif.cloudfunctions.net/gcp-tts-rate-limited';
        const AVATAR_URL = 'https://models.readyplayer.me/64bfa15f0e72c63d7c3934a6.glb?morphTargets=ARKit,Oculus+Visemes,mouthOpen,mouthSmile,eyesClosed,eyesLookUp,eyesLookDown';

        let EMOJI_CHAR, NON_TTS;
        try {
        EMOJI_CHAR = /[\p{Emoji_Presentation}\p{Extended_Pictographic}]/u;
        NON_TTS    = /[^\p{L}\p{N}\p{P}\p{Z}\n\r\t]/gu;
        } catch {
        EMOJI_CHAR = /[\u{1F300}-\u{1FAFF}\u{2600}-\u{27BF}]/u;
        NON_TTS    = /[^A-Za-z0-9\s.,!?;:'"()[\]{}<>@#$%^&*_\-+=/\\|~`]/g;
        }
        function extractEmojisAndSanitize(text = "") {
        const chars = Array.from(text);
        const emojis = [];
        const noEmoji = chars.map(ch => {
            if (EMOJI_CHAR.test(ch)) { emojis.push(ch); return ""; }
            return ch;
        }).join("");
        let clean = noEmoji.replace(NON_TTS, "").replace(/\s{2,}/g, " ").trim();
        return { clean, emojis };
        }
        function sanitizeForTTS(s) {
        return extractEmojisAndSanitize(s).clean;
        }

        const setupScreen = document.getElementById('setup-screen');
        const loadingScreen = document.getElementById('loading-screen');
        const permissionsModal = document.getElementById('permissions-modal');
        const interviewScreen = document.getElementById('interview-screen');
        const setupForm = document.getElementById('setup-form');
        const avatarContainer = document.getElementById('avatar-container');
        const modelLoadingOverlay = document.getElementById('model-loading-overlay');
        const chatMessages = document.getElementById('chat-messages');
        const userVideo = document.getElementById('user-video');
        const subtitlesOverlay = document.getElementById('subtitles-overlay');
        const currentRoleSpan = document.getElementById('current-role');
        const loadingProgressBar = document.getElementById('loading-progress-bar');
        const pushToTalkBtn = document.getElementById('push-to-talk-btn');
        const speechStatus = document.getElementById('speech-status');
        const scorePill = document.getElementById('score-pill');
        const progressPill = document.getElementById('progress-pill');

        const subtitlesBtn = document.getElementById('subtitles-btn');
        const endCallBtn = document.getElementById('end-call-btn');
        const allowPermissionsBtn = document.getElementById('allow-permissions');
        const skipPermissionsBtn = document.getElementById('skip-permissions');

        let interimTranscript = '';
        let finalTranscript = '';

        async function init() {
            setupEventListeners();
            setupSpeechRecognition();
            loadModelInBackground();
            subtitlesBtn.classList.toggle('active', areSubtitlesOn);
        }

        function setupEventListeners() {
            setupForm.addEventListener('submit', handleSetupSubmit);
            subtitlesBtn.addEventListener('click', toggleSubtitles);
            endCallBtn.addEventListener('click', endInterview);
            
            if (allowPermissionsBtn) {
                allowPermissionsBtn.addEventListener('click', requestPermissions);
            }
            if (skipPermissionsBtn) {
                skipPermissionsBtn.addEventListener('click', skipPermissions);
            }

            pushToTalkBtn.addEventListener('mousedown', startRecording);
            pushToTalkBtn.addEventListener('mouseup', stopRecording);
            pushToTalkBtn.addEventListener('mouseleave', stopRecording);
            pushToTalkBtn.addEventListener('touchstart', startRecording, { passive: false });
            pushToTalkBtn.addEventListener('touchend', stopRecording);
            pushToTalkBtn.addEventListener('touchcancel', stopRecording);

            window.addEventListener('resize', () => {
                if (avatar) avatar.onResize();
            });
        }

        function setupSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                speechRecognition = new SpeechRecognition();
                speechRecognition.continuous = false;
                speechRecognition.interimResults = true;
                speechRecognition.lang = 'en-US';

                speechRecognition.onstart = () => {
                    interimTranscript = '';
                    finalTranscript = '';
                    updateSpeechStatus('Listening...', true);
                };

                speechRecognition.onresult = (event) => {
                    let combined = '';
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const text = event.results[i][0].transcript;
                        if (event.results[i].isFinal) {
                            finalTranscript += text;
                        } else {
                            interimTranscript += text;
                        }
                        combined += text + ' ';
                    }
                    const seen = combined.trim();
                    updateSpeechStatus(seen ? `You said: ${seen}` : 'Listening...', true);
                    if (areSubtitlesOn && seen) {
                        showSubtitles(`${timestampNow()} You: ${seen}`);
                    }
                };

                speechRecognition.onend = () => {
                    const toSend = (finalTranscript || interimTranscript).trim();
                    if (toSend && !isWaitingForAIResponse) {
                        if (areSubtitlesOn) showSubtitles(`${timestampNow()} You: ${toSend}`);
                        handleSpeechInput(toSend);
                    }
                    updateSpeechStatus('', false);
                };

                speechRecognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                    updateSpeechStatus('Speech recognition error', false);
                };
            }
        }

        function startRecording(event) {
            event.preventDefault();
            if (isRecording || isWaitingForAIResponse) return;

            isRecording = true;
            pushToTalkBtn.classList.add('recording');
            interimTranscript = '';
            finalTranscript = '';
            
            if (speechRecognition) {
                try {
                    speechRecognition.start();
                } catch (error) {
                    console.error('Failed to start speech recognition:', error);
                    updateSpeechStatus('Speech recognition not available', false);
                }
            } else {
                updateSpeechStatus('Speech recognition not supported', false);
            }
        }

        function stopRecording(event) {
            event.preventDefault();
            if (!isRecording) return;

            isRecording = false;
            pushToTalkBtn.classList.remove('recording');
            
            if (speechRecognition) {
                try {
                    speechRecognition.stop();
                } catch (e) {
                    const toSend = (finalTranscript || interimTranscript).trim();
                    if (toSend && !isWaitingForAIResponse) {
                        if (areSubtitlesOn) showSubtitles(`${timestampNow()} You: ${toSend}`);
                        handleSpeechInput(toSend);
                    }
                }
            } else {
                const toSend = (finalTranscript || interimTranscript).trim();
                if (toSend && !isWaitingForAIResponse) {
                    if (areSubtitlesOn) showSubtitles(`${timestampNow()} You: ${toSend}`);
                    handleSpeechInput(toSend);
                }
            }
        }

        function updateSpeechStatus(text, visible) {
            speechStatus.textContent = text;
            speechStatus.classList.toggle('visible', visible);
        }

        function handleSpeechInput(transcript) {
            if (!transcript.trim() || isWaitingForAIResponse) return;
            addChatMessage('user', 'You', transcript);
            sendToAI(transcript);
        }

        async function loadModelInBackground() {
            try {
                avatar = new TalkingHead(avatarContainer, { 
                    ttsEndpoint: TTS_ENDPOINT,
                    cameraView: 'head' 
                });
                await avatar.init();

                avatar.onResize();
                setTimeout(() => avatar && avatar.onResize(), 150);
                
                updateLoadingProgress(30, 'Loading 3D model...');
                await avatar.showAvatar({ url: AVATAR_URL });
                
                updateLoadingProgress(70, 'Optimizing performance...');
                await new Promise(resolve => setTimeout(resolve, 400));
                
                updateLoadingProgress(100, 'Ready!');
                isModelLoaded = true;
                modelLoadingOverlay.classList.add('hidden');
                loadingScreen.classList.add('hidden');

                setTimeout(() => avatar && avatar.onResize(), 50);
                setTimeout(() => avatar && avatar.onResize(), 300);
                window.dispatchEvent(new Event('resize'));
            } catch (error) {
                console.error('Failed to load avatar:', error);
                updateLoadingProgress(0, 'Failed to load model. Please refresh.');
            }
        }

        function updateLoadingProgress(percent, text) {
            loadingProgressBar.style.width = `${percent}%`;
            const lt = document.querySelector('.loading-text');
            if (lt) lt.textContent = text;
        }

        async function handleSetupSubmit(e) {
            e.preventDefault();
            
            interviewConfig = {
                specialization: document.getElementById('specialization').value,
                experienceLevel: document.getElementById('experience-level').value,
                companyType: document.getElementById('company-type').value,
                duration: document.getElementById('interview-duration').value
            };

            currentRoleSpan.textContent = interviewConfig.specialization;

            setupScreen.classList.add('hidden');
            
            if (!isModelLoaded) {
                loadingScreen.classList.remove('hidden');
                while (!isModelLoaded) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                loadingScreen.classList.add('hidden');
            }
            
            try {
                const existing = await navigator.mediaDevices.getUserMedia({ video: false, audio: true });
                existing.getTracks().forEach(t => t.stop());
                skipPermissions();
            } catch (error) {
                permissionsModal.classList.remove('hidden');
            }
        }

        async function requestPermissions() {
            try {
                await ensureUserMedia(true);
                permissionsModal.classList.add('hidden');
                startInterview();
            } catch (error) {
                console.error('Failed to get media permissions:', error);
                alert('Camera/microphone access was denied. You can still continue with the interview.');
                skipPermissions();
            }
        }

        function skipPermissions() {
            permissionsModal.classList.add('hidden');
            startInterview();
        }

        async function ensureUserMedia(showVideo = false) {
            try {
                userStream = await navigator.mediaDevices.getUserMedia({ 
                    video: showVideo ? { facingMode: 'user' } : { facingMode: 'user' }, 
                    audio: true 
                });
                if (userVideo) {
                    userVideo.srcObject = userStream;
                    await userVideo.play().catch(() => {});
                }
            } catch (e) {
                console.warn('User media not available:', e);
            }
        }

        async function startInterview() {
            interviewScreen.classList.remove('hidden');
            scores = [];
            updateScoreAndProgress();

            messages = [];
            isWaitingForAIResponse = false;

            await ensureUserMedia(false);
            
            if (!isModelLoaded) {
                while (!isModelLoaded) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            setTimeout(() => avatar && avatar.onResize(), 50);
            
            const welcomeMessage = 'Welcome to your AI video interview! I\'m Alex, and I\'ll be conducting your interview today. Are you ready to begin?';
            addChatMessage('ai', 'Alex Johnson', welcomeMessage);
            if (avatar) avatar.speakText(welcomeMessage);
            if (areSubtitlesOn) {
                showSubtitles(`${timestampNow()} Alex: ${welcomeMessage}`);
            }
        }

        function addChatMessage(type, author, content) {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${type}`;
            messageEl.innerHTML = `
                <div class="message-author">${author}</div>
                <div class="message-content">${content}</div>
            `;
            chatMessages.appendChild(messageEl);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        async function sendToAI(message) {
            if (isWaitingForAIResponse) return;
            isWaitingForAIResponse = true;
            
            try {
                messages.push({ role: 'user', content: message });
                
                const response = await fetch(WORKER_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Specialization': interviewConfig.specialization,
                        'X-Experience-Level': interviewConfig.experienceLevel,
                        'X-Company-Type': interviewConfig.companyType,
                        'X-Duration': interviewConfig.duration
                    },
                    body: JSON.stringify({ messages })
                });

                if (!response.ok) {
                    throw new Error(`API Error: ${response.statusText}`);
                }

                const data = await response.json();
                if (data.ok && data.response) {
                    let aiMessage = data.response;
                    let score = null;
                    if (data.meta && typeof data.meta.score === 'number') {
                        score = data.meta.score;
                    } else {
                        const m = aiMessage.match(/<<<SCORE\s+(\d+(?:\.\d+)?)\/10>>>/i);
                        if (m) {
                            score = parseFloat(m[1]);
                            aiMessage = aiMessage.replace(/<<<SCORE\s+\d+(?:\.\d+)?\/10>>>/i, '').trim();
                        }
                    }

                    const ended = !!(data.meta && data.meta.ended);
                    const progress = data.meta && typeof data.meta.progress === 'number' ? data.meta.progress : undefined;
                    /*
                    messages.push({ role: 'assistant', content: aiMessage });
                    addChatMessage('ai', 'Alex Johnson', aiMessage);
                    
                    if (areSubtitlesOn) {
                        showSubtitles(`${timestampNow()} Alex: ${aiMessage}`);
                    }
                    if (avatar && isModelLoaded) {
                        avatar.speakText(aiMessage);
                    }*/
                    messages.push({ role: 'assistant', content: aiMessage });
                    addChatMessage('ai', 'Alex Johnson', aiMessage);

                    const { clean, emojis } = extractEmojisAndSanitize(aiMessage);

                    if (avatar && isModelLoaded) {
                    emojis.slice(0, 3).forEach((e, i) => {
                        const known = avatar.animEmojis[e] ? e : 'ðŸ˜Š';
                        setTimeout(() => avatar.speakEmoji(known), i * 400);
                    });
                    avatar.speakText(clean);
                    }

                    if (areSubtitlesOn) {
                    showSubtitles(`${timestampNow()} Alex: ${aiMessage}`);
                    }


                    if (typeof score === 'number') {
                        scores.push(score);
                        updateScoreAndProgress(progress);
                        addChatMessage('ai', 'Score', `Assessment for your last answer: ${score.toFixed(1)}/10`);
                    }

                    if (/<<<FINAL_INTERVIEW_REPORT>>>/i.test(aiMessage)) {
                        addChatMessage('ai', 'Final Report', aiMessage);
                    }

                    if (ended) {
                        addChatMessage('ai', 'System', 'Interview concluded. You can end the call or review the chat.');
                    }
                } else {
                    throw new Error(data.error || 'Invalid response from AI');
                }

            } catch (error) {
                console.error('AI communication error:', error);
                addChatMessage('ai', 'System', 'I apologize, but I\'m having trouble processing your response. Please try again.');
            } finally {
                isWaitingForAIResponse = false;
            }
        }

        function timestampNow() {
            const now = new Date();
            const hh = String(now.getHours()).padStart(2,'0');
            const mm = String(now.getMinutes()).padStart(2,'0');
            const ss = String(now.getSeconds()).padStart(2,'0');
            return `[${hh}:${mm}:${ss}]`;
        }

        function showSubtitles(text) {
            subtitlesOverlay.textContent = text;
            subtitlesOverlay.classList.remove('hidden');
            const displayDuration = Math.max(2500, text.length * 50);
            if (subtitlesOverlay._hideTimer) clearTimeout(subtitlesOverlay._hideTimer);
            subtitlesOverlay._hideTimer = setTimeout(() => {
                subtitlesOverlay.classList.add('hidden');
            }, displayDuration);
        }

        function scheduleAISubtitles(sortedTP, totalDurationSec, audioStartAt) {
            if (!areSubtitlesOn || !sortedTP || !sortedTP.length) return;
            if (subtitlesOverlay._sched) {
                subtitlesOverlay._sched.forEach(id => clearTimeout(id));
            }
            const ids = [];
            const words = [];
            const startEpoch = performance.now();
            const offsetMs = (audioStartAt - avatar.audioCtx.currentTime) * 1000;

            sortedTP.forEach((tp, idx) => {
                const atMs = tp.time_seconds * 1000 + offsetMs;
                const when = Math.max(0, atMs);
                words.push(tp.word);
                const textAtIdx = `${timestampNow()} Alex: ${words.join(' ')}`;
                const id = setTimeout(() => {
                    showSubtitles(textAtIdx);
                }, when);
                ids.push(id);
            });
            const totalMs = totalDurationSec * 1000 + offsetMs + 400;
            ids.push(setTimeout(() => {
                subtitlesOverlay.classList.add('hidden');
            }, Math.max(0, totalMs)));
            subtitlesOverlay._sched = ids;
        }

        function toggleSubtitles() {
            areSubtitlesOn = !areSubtitlesOn;
            document.getElementById('subtitles-btn').classList.toggle('active', areSubtitlesOn);
            if (!areSubtitlesOn) {
                subtitlesOverlay.classList.add('hidden');
            }
        }

        function updateScoreAndProgress(progress) {
            if (scores.length) {
                const avg = scores.reduce((a,b)=>a+b,0)/scores.length;
                scorePill.textContent = `Avg Score: ${avg.toFixed(1)}/10`;
            } else {
                scorePill.textContent = 'Avg Score: â€”';
            }
            if (typeof progress === 'number') {
                progressPill.textContent = `Progress: ${Math.round(progress)}%`;
            }
        }

        function endInterview() {
            if (confirm('Are you sure you want to end the interview?')) {
                if (userStream) {
                    userStream.getTracks().forEach(track => track.stop());
                }
                if (avatar) {
                    avatar.stopSpeaking();
                }
                interviewScreen.classList.add('hidden');
                setupScreen.classList.remove('hidden');
                messages = [];
                isModelLoaded = false;
                areSubtitlesOn = true;
                isWaitingForAIResponse = false;
                scores = [];
                chatMessages.innerHTML = '';
                modelLoadingOverlay.classList.remove('hidden');
                loadModelInBackground();
            }
        }

        init();
    </script>
</body>
</html>