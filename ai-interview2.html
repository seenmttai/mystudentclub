<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Video Interview - Professional Practice Platform</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary: #4f46e5;
      --primary-light: #6366f1;
      --secondary: #6b7280;
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
      --bg-primary: #030712;
      --bg-secondary: #111827;
      --bg-tertiary: #1f2937;
      --text-primary: #f9fafb;
      --text-secondary: #d1d5db;
      --text-muted: #9ca3af;
      --border: #374151;
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
      --border-radius: 0.75rem;
      --transition: all 0.2s ease-in-out;
    }

    .hidden {
      display: none !important;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background-color: var(--bg-primary);
      background-image: radial-gradient(ellipse 80% 50% at 50% -20%, rgba(120, 119, 198, 0.3), transparent);
      color: var(--text-primary);
      min-height: 100vh;
      overflow-x: hidden;
    }

    .setup-container {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      position: relative;
    }

    .subtitles-overlay {
      position: absolute;
      left: 50%;
      bottom: 76px;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, .65);
      color: #fff;
      padding: .6rem .9rem;
      border-radius: 10px;
      font-size: 1rem;
      line-height: 1.35;
      max-width: 88%;
      text-align: center;
      z-index: 20;
      pointer-events: none;
      white-space: pre-wrap;
    }


    .setup-container::before {
      display: none;
    }

    .setup-card {
      background: rgba(17, 24, 39, 0.6);
      backdrop-filter: blur(24px);
      border: 1px solid transparent;
      background-clip: padding-box;
      border-image: linear-gradient(to bottom right, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05)) 1;
      border-radius: 24px;
      padding: 3rem;
      max-width: 600px;
      width: 100%;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      position: relative;
      z-index: 2;
    }

    .setup-header {
      text-align: center;
      margin-bottom: 2.5rem;
    }

    .setup-logo {
      width: 56px;
      height: 56px;
      background: linear-gradient(135deg, var(--primary), var(--primary-light));
      border-radius: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 1.5rem;
      box-shadow: 0 0 20px rgba(79, 70, 229, 0.4);
    }

    .setup-title {
      font-size: 2.25rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--text-primary), var(--text-secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 0.75rem;
    }

    .setup-subtitle {
      color: var(--text-muted);
      font-size: 1.1rem;
      line-height: 1.6;
      max-width: 450px;
      margin: 0 auto;
    }

    .form-grid {
      display: grid;
      gap: 1.5rem;
      margin-top: 2.5rem;
    }

    .form-group {
      display: flex;
      flex-direction: column;
    }

    .form-label {
      font-weight: 500;
      margin-bottom: 0.5rem;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .form-input,
    .form-select {
      padding: 0.875rem 1rem;
      background: rgba(17, 24, 39, 0.8);
      border: 1px solid var(--border);
      border-radius: var(--border-radius);
      color: var(--text-primary);
      font-size: 1rem;
      transition: var(--transition);
    }

    .select-wrapper {
      position: relative;
      display: block;
    }

    .select-wrapper::after {
      content: "â–¾";
      position: absolute;
      right: 14px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--text-secondary);
      pointer-events: none;
      font-size: 0.95rem;
    }

    .form-select {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      color-scheme: dark;
      width: 100%;
      line-height: 1.2;
      cursor: pointer;

      background-color: var(--bg-secondary);
      color: var(--text-primary);
      border-color: var(--border);
    }

    .form-select:hover {
      background-color: #0b1220;
    }

    .form-select:focus {
      outline: none;
      border-color: var(--primary-light);
      background-color: #0b1220;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25);
    }


    .form-select option,
    .form-select optgroup {
      background-color: #0b1220 !important;
      color: #f9fafb !important;
    }

    .form-select option:checked,
    .form-select option:focus,
    .form-select option:hover {
      background-color: #1e40af !important;
      color: #ffffff !important;
    }


    @media (-ms-high-contrast: active) {
      .form-select {
        border: 2px solid windowText;
      }
    }


    .form-select::-webkit-scrollbar {
      width: 12px;
    }

    .form-select::-webkit-scrollbar-track {
      background: #0b1220;
    }

    .form-select::-webkit-scrollbar-thumb {
      background-color: #334155;
      border-radius: 8px;
      border: 3px solid #0b1220;
    }


    @-moz-document url-prefix() {

      .form-select,
      .form-select option,
      .form-select optgroup {
        background-color: #0b1220 !important;
        color: #f9fafb !important;
      }
    }

    .form-input:focus,
    .form-select:focus {
      outline: none;
      border-color: var(--primary-light);
      background: var(--bg-secondary);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
    }

    .btn {
      padding: 1rem 2rem;
      border: none;
      border-radius: var(--border-radius);
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      transition: var(--transition);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      position: relative;
      overflow: hidden;
    }

    .btn-primary {
      background-image: linear-gradient(to right, #4f46e5 0%, #7c3aed 50%, #4f46e5 100%);
      background-size: 200% auto;
      color: white;
      box-shadow: 0 4px 15px 0 rgba(79, 70, 229, 0.35);
    }

    .btn-primary:hover {
      background-position: right center;
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(79, 70, 229, 0.4);
    }

    .btn-primary:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }


    .loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--bg-primary);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .loading-spinner {
      width: 48px;
      height: 48px;
      border: 3px solid rgba(59, 130, 246, 0.2);
      border-top: 3px solid var(--primary-light);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 1.5rem;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    .loading-text {
      color: var(--text-secondary);
      font-size: 1.1rem;
      margin-bottom: 0.5rem;
    }

    .loading-progress {
      width: 200px;
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      overflow: hidden;
    }

    .loading-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--primary), var(--primary-light));
      width: 0%;
      transition: width 0.5s ease;
    }


    .interview-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--bg-primary);
      display: flex;
      flex-direction: column;
    }

    .interview-header {
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      padding: 1rem 2rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid var(--border);
      z-index: 10;
    }

    .interview-title {
      font-weight: 600;
      color: var(--text-primary);
    }

    .interview-controls {
      display: flex;
      gap: 1rem;
      margin-left: auto;
    }

    .control-btn {
      width: 40px;
      height: 40px;
      border: none;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-primary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: var(--transition);
    }

    .control-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .control-btn.active {
      background: var(--primary-light);
    }

    .control-btn.danger {
      background: var(--error);
    }

    .interview-main {
      flex: 1;
      display: grid;
      grid-template-columns: 1fr 340px;
      gap: 1rem;
      padding: 1rem;
      overflow: hidden;
      padding-bottom: 96px;
    }

    .main-video {
      background: var(--bg-secondary);
      border-radius: var(--border-radius);
      position: relative;
      overflow: hidden;
      min-height: 400px;
      border: 1px solid var(--border);
    }

    .avatar-container {
      width: 100%;
      height: 100%;
      position: relative;
    }

    .video-overlay {
      position: absolute;
      bottom: 1rem;
      left: 1rem;
      right: 1rem;
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      pointer-events: none;
    }

    .participant-info {
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      padding: 0.5rem 1rem;
      border-radius: 8px;
      color: white;
      font-size: 0.9rem;
      font-weight: 500;
    }

    .video-status {
      display: flex;
      gap: 0.5rem;
    }

    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--success);
      box-shadow: 0 0 8px var(--success);
    }

    .status-indicator.muted {
      background: var(--error);
      box-shadow: 0 0 8px var(--error);
    }

    .sidebar {
      width: 340px;
      background: var(--bg-secondary);
      border-radius: var(--border-radius);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      border: 1px solid var(--border);
    }

    .user-video {
      height: 180px;
      background: var(--bg-tertiary);
      position: relative;
      border-radius: var(--border-radius) var(--border-radius) 0 0;
      border-bottom: 1px solid var(--border);
    }

    .user-video video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .chat-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 1rem;
      overflow: hidden;
      min-height: 0;
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      margin-bottom: 1rem;
      max-height: 100%;
      scrollbar-width: thin;
    }

    .message {
      margin-bottom: 1rem;
      max-width: 90%;
    }

    .message.ai {
      align-self: flex-start;
    }

    .message.user {
      align-self: flex-end;
    }

    .message-author {
      font-weight: 600;
      font-size: 0.85rem;
      margin-bottom: 0.35rem;
      color: var(--text-secondary);
    }

    .message-content {
      padding: 0.75rem 1rem;
      border-radius: 12px;
      line-height: 1.5;
      color: var(--text-primary);
    }

    .message.ai .message-content {
      background: var(--bg-tertiary);
      border-top-left-radius: 2px;
    }

    .message.user .message-content {
      background: var(--primary);
      color: white;
      border-top-right-radius: 2px;
    }

    .chat-input-container {
      display: flex;
      gap: 0.5rem;
    }

    .chat-input {
      flex: 1;
      padding: 0.75rem;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 8px;
      color: var(--text-primary);
      resize: none;
      min-height: 40px;
      max-height: 100px;
    }

    .send-btn {
      width: 40px;
      height: 40px;
      background: var(--primary-light);
      border: none;
      border-radius: 8px;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: var(--transition);
    }

    .send-btn:hover {
      background: var(--primary);
    }


    .push-to-talk-container {
      position: relative;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .push-to-talk-btn {
      width: 56px;
      height: 56px;
      border: 3px solid var(--primary-light);
      border-radius: 50%;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: var(--transition);
      font-size: 1.3rem;
      position: relative;
    }

    .push-to-talk-btn:hover {
      background: rgba(59, 130, 246, 0.1);
      border-color: var(--primary);
    }

    .push-to-talk-btn.recording {
      background: var(--error);
      border-color: var(--error);
      color: white;
      animation: pulse-recording 1.5s infinite;
    }

    @keyframes pulse-recording {
      0% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.05);
      }

      100% {
        transform: scale(1);
      }
    }

    .push-to-talk-hint {
      font-size: 0.85rem;
      color: var(--text-muted);
      margin-left: 0.5rem;
    }


    .speech-status {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      font-size: 0.8rem;
      white-space: nowrap;
      margin-bottom: 0.5rem;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .speech-status.visible {
      opacity: 1;
    }


    .interview-footer {
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(10px);
      padding: 1rem 2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      border-top: 1px solid var(--border);
    }

    .footer-controls {
      display: flex;
      gap: 1rem;
    }

    .footer-btn {
      width: 48px;
      height: 48px;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: var(--transition);
      font-size: 1.2rem;
    }

    .footer-btn.mic {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .footer-btn.mic.muted {
      background: var(--error);
      color: white;
    }

    .footer-btn.camera {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .footer-btn.camera.off {
      background: var(--error);
      color: white;
    }

    .footer-btn.end-call {
      background: var(--error);
      color: white;
    }

    .footer-btn.subtitles {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .footer-btn.subtitles.active {
      background: var(--primary-light);
      color: white;
    }


    @media (max-width: 768px) {
      .setup-card {
        padding: 2rem;
        margin: 1rem;
      }

      .setup-title {
        font-size: 2rem;
      }

      .interview-main {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto;
        padding-bottom: 108px;
      }

      .main-video {
        min-height: 260px;
        height: 55vh;
      }

      .sidebar {
        width: 100%;
        height: auto;
        max-height: calc(45vh - 8px);
        display: grid;
        grid-template-columns: 180px 1fr;
      }

      .user-video {
        width: 200px;
        height: 100%;
        border-radius: var(--border-radius) 0 0 var(--border-radius);
        flex-shrink: 0;
      }

      .chat-section {
        min-height: 140px;
        overflow: hidden;
      }

      .chat-messages {
        max-height: calc(45vh - 60px);
        overflow-y: auto;
      }

      .subtitles-overlay {
        bottom: 96px;
        font-size: 0.9rem;
        max-width: 92%;
      }
    }

    @media (max-width: 480px) {
      .sidebar {
        grid-template-columns: 140px 1fr;
      }

      .main-video {
        min-height: 240px;
        height: 52vh;
      }
    }


    .floating-ptt {
      position: fixed;
      right: 16px;
      bottom: 88px;
      z-index: 1100;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      pointer-events: none;
    }

    .floating-ptt .push-to-talk-container {
      pointer-events: auto;
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.1);
      padding: 8px 10px;
      border-radius: 14px;
      backdrop-filter: blur(8px);
    }

    @media (max-width: 768px) {
      .floating-ptt {
        bottom: 96px;
        right: 12px;
      }
    }

    /* hide self camera on mobile and simplify sidebar layout */
    @media (max-width: 768px) {
      .user-video {
        display: none;
      }

      .sidebar {
        width: 100%;
        grid-template-columns: 1fr;
      }
    }

    /* Hide mobile chat UI by default (desktop), show only on mobile */
    @media (min-width: 769px) {

      #mobile-chat-fab,
      #mobile-chat-sheet {
        display: none;
      }
    }

    @media (max-width: 768px) {
      .mobile-chat-fab {
        position: fixed;
        right: 16px;
        bottom: 156px;
        background: #111827;
        color: #fff;
        border: 1px solid rgba(255, 255, 255, .12);
        padding: .6rem .9rem;
        border-radius: 999px;
        box-shadow: var(--shadow);
        z-index: 1200;
        display: inline-flex;
        align-items: center;
      }

      .mobile-chat-sheet {
        position: fixed;
        left: 0;
        right: 0;
        bottom: -100%;
        height: 70vh;
        background: #0f172a;
        border-top: 1px solid var(--border);
        border-radius: 16px 16px 0 0;
        display: flex;
        flex-direction: column;
        transition: transform .25s ease;
        transform: translateY(100%);
        z-index: 1300;
      }

      /* Ensure visibility on mobile */
      #mobile-chat-fab {
        display: inline-flex !important;
        z-index: 2000;
      }

      #mobile-chat-sheet {
        display: flex !important;
        z-index: 2100;
      }
    }
  </style>
  <script type="importmap">
    { 
      "imports": { 
        "three": "https://unpkg.com/three@0.149.0/build/three.module.js", 
        "three/addons/": "https://unpkg.com/three@0.149.0/examples/jsm/",
        "lipsync-en": "https://cdn.jsdelivr.net/gh/met4citizen/TalkingHead@1.2/modules/lipsync-en.mjs"
      } 
    }
    </script>
</head>

<body>

  <div id="setup-screen" class="setup-container">
    <div class="setup-card fade-in">
      <div class="setup-header">
        <div class="setup-logo">
          <svg width="32" height="32" viewBox="0 0 24 24" fill="white">
            <path
              d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z" />
          </svg>
        </div>
        <h1 class="setup-title">AI Video Interview</h1>
        <p class="setup-subtitle">Practice with our AI interviewer and get instant feedback on your performance</p>
      </div>

      <form id="setup-form" class="form-grid">
        <div class="form-group">
          <label class="form-label" for="specialization">Target Role</label>
          <div class="select-wrapper">
            <select id="specialization" class="form-select">
              <optgroup label="CA & Accounting (Recommended)">
                <option value="Chartered Accountant - Audit" selected>Chartered Accountant â€” Audit</option>
                <option value="Chartered Accountant - Taxation">Chartered Accountant â€” Taxation</option>
                <option value="Management Accountant (CMA)">Management Accountant (CMA)</option>
                <option value="Financial Controller">Financial Controller</option>
                <option value="Statutory Auditor">Statutory Auditor</option>
                <option value="IFRS Specialist">IFRS Specialist</option>
                <option value="GST/Indirect Tax Specialist">GST / Indirect Tax Specialist</option>
                <option value="Direct Tax Consultant">Direct Tax Consultant</option>
                <option value="Risk & Compliance (SOX/ICFR)">Risk & Compliance (SOX / ICFR)</option>
                <option value="Treasury Analyst">Treasury Analyst</option>
                <option value="Corporate Finance Associate">Corporate Finance Associate</option>
                <option value="Forensic Accountant">Forensic Accountant</option>
              </optgroup>
              <optgroup label="Other Roles">
                <option value="Finance Analyst">Finance Analyst</option>
                <option value="Business Analyst">Business Analyst</option>
                <option value="Product Manager">Product Manager</option>
                <option value="Data Scientist">Data Scientist</option>
                <option value="Software Engineer">Software Engineer</option>
                <option value="UX Designer">UX Designer</option>
                <option value="Marketing Manager">Marketing Manager</option>
                <option value="Sales Representative">Sales Representative</option>
              </optgroup>
            </select>
          </div>
        </div>

        <div class="form-group">
          <label class="form-label" for="experience-level">Experience Level</label>
          <div class="select-wrapper">
            <select id="experience-level" class="form-select">
              <option value="Article/Intern">Article/Intern</option>
              <option value="Entry Level" selected>Entry Level (0-2 years)</option>
              <option value="Mid Level">Mid Level (3-5 years)</option>
              <option value="Senior Level">Senior Level (6-10 years)</option>
              <option value="Executive Level">Executive Level (10+ years)</option>
            </select>
          </div>
        </div>

        <div class="form-group">
          <label class="form-label" for="company-type">Company Type</label>
          <div class="select-wrapper">
            <select id="company-type" class="form-select">
              <option value="Big 4 (Audit/Tax)">Big 4 (Audit/Tax)</option>
              <option value="Mid-size CA Firm">Mid-size CA Firm</option>
              <option value="Corporate (Industry)">Corporate (Industry)</option>
              <option value="Consulting Firm">Consulting Firm</option>
              <option value="Fortune 500">Fortune 500</option>
              <option value="Tech Startup">Tech Startup</option>
              <option value="Healthcare">Healthcare</option>
              <option value="Government">Government</option>
              <option value="Non-Profit">Non-Profit</option>
              <option value="Investment Bank">Investment Bank</option>
            </select>
          </div>
        </div>

        <div class="form-group">
          <label class="form-label" for="interview-duration">Interview Duration</label>
          <div class="select-wrapper">
            <select id="interview-duration" class="form-select">
              <option value="15">15 minutes</option>
              <option value="30" selected>30 minutes</option>
              <option value="45">45 minutes</option>
              <option value="60">60 minutes</option>
            </select>
          </div>
        </div>

        <button type="submit" class="btn btn-primary">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <path d="M8 5v14l11-7z" />
          </svg>
          Start Interview
        </button>
      </form>
    </div>
  </div>


  <div id="loading-screen" class="loading-screen hidden">
    <div class="loading-spinner"></div>
    <div class="loading-text">Preparing your interview...</div>
    <div class="loading-progress">
      <div class="loading-progress-bar" id="loading-progress-bar"></div>
    </div>
  </div>


  <div id="permissions-modal" class="permissions-modal hidden">
    <div class="permissions-content">
      <h2 class="permissions-title">Camera & Microphone Access</h2>
      <p class="permissions-text">
        To provide the best interview experience, we need access to your camera and microphone.
        This helps our AI interviewer analyze your verbal and non-verbal communication.
      </p>
      <div class="permissions-actions">
        <button id="allow-permissions" class="btn btn-primary">Allow Access</button>
        <button id="skip-permissions" class="btn"
          style="background: var(--bg-tertiary); color: var(--text-primary);">Skip for now</button>
      </div>
    </div>
  </div>


  <div id="interview-screen" class="interview-container hidden">
    <header class="interview-header">
      <div class="interview-title">
        AI Video Interview - <span id="current-role">Software Engineer</span>
        <span class="pills">
          <span id="score-pill" class="pill success">Avg Score: â€”</span>
          <span id="progress-pill" class="pill info">Progress: 0%</span>
        </span>
      </div>
      <div class="interview-controls">
      </div>
    </header>

    <main class="interview-main">
      <div class="main-video">
        <div id="avatar-container" class="avatar-container">
          <div id="model-loading-overlay" class="model-loading-overlay">
            <div class="loading-spinner"></div>
            <div style="color: var(--text-secondary); margin-top: 1rem;">Loading AI Interviewer...</div>
          </div>
        </div>
        <div class="video-overlay">
          <div class="participant-info">
            Alex Johnson - AI Interviewer
          </div>
          <div class="video-status">
            <div class="status-indicator" id="ai-audio-status"></div>
          </div>
        </div>
        <div id="subtitles-overlay" class="subtitles-overlay hidden"></div>
      </div>

      <aside class="sidebar">
        <div class="user-video">
          <video id="user-video" autoplay muted playsinline></video>
          <div class="video-overlay" style="bottom: 0.5rem; left: 0.5rem; right: 0.5rem;">
            <div class="participant-info" style="font-size: 0.8rem;">
              You
            </div>
            <div class="video-status">
              <div class="status-indicator" id="user-audio-status"></div>
            </div>
          </div>
        </div>

        <div class="chat-section">
          <div id="chat-messages" class="chat-messages"></div>
        </div>
      </aside>
    </main>

    <footer class="interview-footer">
      <div class="footer-controls">
        <button id="subtitles-btn" class="footer-btn subtitles" title="Toggle Subtitles">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <path
              d="M19 4H5c-1.66 0-3.15.25-4.6.72v3.1c0 .39-.23.74-.56.9-.98.49-1.87 1.12-2.66 1.85-.18.18-.43.28-.7.28-.28 0-.53-.11-.71-.29L.29 13.08c-.18-.17-.29-.42-.29-.7 0-.28.11-.53.29-.71C3.34 8.78 7.46 7 12 7s8.66 1.78 11.71 4.67c.18.18.29.43.29.71 0 .28-.11.53-.29.71l-2.48 2.48c-.18.18-.43.29-.71.29-.79-.73-1.68-1.36-2.66-1.85-.33-.16-.56-.51-.56-.9v-3.1C15.15 9.25 13.6 9 12 9z" />
          </svg>
        </button>
        <button id="end-call-btn" class="footer-btn end-call" title="End Interview">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <path
              d="M12 9c-1.66 0-3.15.25-4.6.72v3.1c0 .39-.23.74-.56.9-.98.49-1.87 1.12-2.66 1.85-.18.18-.43.28-.7.28-.28 0-.53-.11-.71-.29L.29 13.08c-.18-.17-.29-.42-.29-.7 0-.28.11-.53.29-.71C3.34 8.78 7.46 7 12 7s8.66 1.78 11.71 4.67c.18.18.29.43.29.71 0 .28-.11.53-.29.71l-2.48 2.48c-.18.18-.43.29-.71.29-.79-.73-1.68-1.36-2.66-1.85-.33-.16-.56-.51-.56-.9v-3.1C15.15 9.25 13.6 9 12 9z" />
          </svg>
        </button>
      </div>
    </footer>


    <div class="floating-ptt" aria-live="polite">
      <div class="push-to-talk-container">
        <button id="push-to-talk-btn" class="push-to-talk-btn" title="Hold to speak" aria-label="Hold to speak">
          <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
            <path
              d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.49 6-3.31 6-6.72h-1.7z" />
          </svg>
        </button>
        <div id="speech-status" class="speech-status" role="status" aria-live="polite"></div>
        <span class="push-to-talk-hint">Hold to speak, release to send</span>
      </div>
    </div>

    <div id="mobile-chat-fab" class="mobile-chat-fab" aria-label="Open chat">Chat</div>
    <div id="mobile-chat-sheet" class="mobile-chat-sheet" aria-hidden="true">
      <div class="sheet-header">
        <span>Chat</span>
        <button id="mobile-chat-close" class="sheet-close" aria-label="Close">Ã—</button>
      </div>
      <div id="mobile-chat-messages" class="sheet-messages"></div>
      <div class="sheet-input">
        <input id="mobile-chat-input" type="text" placeholder="Type your message..." />
        <button id="mobile-send-btn" class="btn btn-primary">Send</button>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
    import { LipsyncEn } from 'lipsync-en';
    // Ensure you have created animations.js in the same folder!
    import { poses, moods, emojis } from './animations.js';

    // --- CONFIGURATION ---
    const AVATAR_URL = 'https://models.readyplayer.me/69440c84ca696e5f2fb7bfd5.glb?morphTargets=ARKit,Oculus+Visemes,mouthOpen,mouthSmile,eyesClosed,eyesLookUp,eyesLookDown';
    const WORKER_URL = 'https://interviewme.bhansalimanan55.workers.dev/';
    const TTS_ENDPOINT = 'https://us-central1-msc-notif.cloudfunctions.net/gcp-tts-rate-limited';

    // --- TALKING HEAD CLASS (THE ANIMATION ENGINE) ---
    class TalkingHead {
      constructor(node, opt = {}) {
        this.nodeAvatar = node;
        this.opt = { ttsEndpoint: null, lipsyncLang: 'en', cameraView: 'upper', ...opt };

        // Renderer Setup
        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        const w = Math.max(this.nodeAvatar.clientWidth || 640, 640);
        const h = Math.max(this.nodeAvatar.clientHeight || 360, 360);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(w, h);
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.nodeAvatar.appendChild(this.renderer.domElement);

        // Camera Setup
        this.camera = new THREE.PerspectiveCamera(25, w / h, 0.1, 100);
        this.scene = new THREE.Scene();

        // Lighting (Optimized for RPM Skin)
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        hemiLight.position.set(0, 20, 0);
        this.scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(0.5, 2, 2); // Front-right
        dirLight.castShadow = true;
        this.scene.add(dirLight);

        const backLight = new THREE.DirectionalLight(0xffffff, 0.8);
        backLight.position.set(-0.5, 2, -2); // Rim light
        this.scene.add(backLight);

        // Controls
        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableZoom = false;
        this.controls.enablePan = false;
        this.controls.target.set(0, 1.58, 0); // Focus on eye level
        this.controls.enableDamping = true;

        // Animation State
        this.animClock = 0;
        this.animTimeLast = 0;
        this.avatar = null;
        this.armature = null;
        this.morphs = [];
        this.mixer = null;
        this.speechQueue = [];
        this.isSpeaking = false;
        this.isRunning = false;
        this.stateName = 'idle';

        // Audio
        this.audioCtx = new AudioContext();
        this.audioSpeechSource = null;
        this.lipsync = {};
        this.visemeNames = ['viseme_sil', 'viseme_PP', 'viseme_FF', 'viseme_TH', 'viseme_DD', 'viseme_kk', 'viseme_CH', 'viseme_SS', 'viseme_nn', 'viseme_RR', 'viseme_aa', 'viseme_E', 'viseme_I', 'viseme_O', 'viseme_U'];

        // Load External Animations
        this.poseTemplates = poses;
        this.animMoods = moods;
        this.animEmojis = emojis;

        // Internal Queues
        this.animQueue = [];
        this.easing = t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

        // Bone Transforms
        this.poseBase = {};
        this.poseTarget = {};
        this.poseAvatar = {};
        this.poseDelta = { props: {} }; // For additive animation (breathing)

        this.animBaseline = {}; // For holding expression states
        this.currentPoseName = 'straight';

        window.addEventListener('resize', this.onResize.bind(this));
      }

      async init() {
        this.lipsync[this.opt.lipsyncLang] = new LipsyncEn();

        // Load HDR Environment for realistic eye reflections
        const rgbe = new RGBELoader();
        try {
          const tex = await new Promise((resolve, reject) => {
            rgbe.load('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_09_1k.hdr', resolve, undefined, reject);
          });
          tex.mapping = THREE.EquirectangularReflectionMapping;
          this.scene.environment = tex;
          // We don't set background to tex to keep it transparent/dark
        } catch (e) {
          console.warn("HDR Env load failed, falling back to standard lights");
        }
      }

      async showAvatar(avatar) {
        const loader = new GLTFLoader();
        const gltf = await loader.loadAsync(avatar.url);
        this.armature = gltf.scene;

        // 1. Traverse and Fix Materials (Crucial for RPM)
        this.armature.traverse(node => {
          if (node.isMesh) {
            node.castShadow = true;
            node.receiveShadow = true;
            node.frustumCulled = false;

            // Material Fixes
            if (node.material) {
              const mat = node.material;
              mat.transparent = false; // Force opaque for most parts
              mat.alphaTest = 0.5;     // Cutout for hair/lashes
              mat.side = THREE.FrontSide;

              // Specific fix for eyes to make them shine
              if (node.name.toLowerCase().includes('eye')) {
                mat.roughness = 0.2;
                mat.metalness = 0.1;
              }
            }

            if (node.morphTargetDictionary) {
              this.morphs.push(node);
            }
          }
        });

        // 2. Setup Bones
        this.poseAvatar.props = {};
        this.poseDelta.props = {};

        // Get all bone names used in poses
        const usedBones = new Set();
        Object.values(this.poseTemplates).forEach(t => Object.keys(t.props).forEach(k => usedBones.add(k)));

        // Initialize Bone States
        usedBones.forEach(key => {
          const [boneName, prop] = key.split('.');
          const bone = this.armature.getObjectByName(boneName);
          if (bone) {
            this.poseAvatar.props[key] = bone[prop];
            this.poseBase.props[key] = bone[prop].clone();
            this.poseTarget.props[key] = bone[prop].clone();
            // Initialize Deltas
            if (prop === 'rotation' || prop === 'quaternion')
              this.poseDelta.props[key] = new THREE.Euler();
            else
              this.poseDelta.props[key] = new THREE.Vector3();
          }
        });

        // Set Initial Pose
        this.setPose('straight', 0);

        this.scene.add(this.armature);
        this.setView(this.opt.cameraView);
        this.start();
      }

      // --- MAIN LOOP ---

      start() {
        if (this.isRunning) return;
        this.isRunning = true;
        this.animTimeLast = performance.now();
        this.startIdleBehavior();
        this.renderer.setAnimationLoop(this.animate.bind(this));
      }

      // Populates the queue with "alive" background animations
      startIdleBehavior() {
        // Remove existing idle loops to prevent stacking
        this.animQueue = this.animQueue.filter(a => a.loop !== -1);

        // Add idle animations from the 'neutral' mood
        if (this.animMoods.neutral && this.animMoods.neutral.anims) {
          this.animMoods.neutral.anims.forEach(anim => {
            this.animQueue.push(this.animFactory(anim));
          });
        }
      }

      animate() {
        const now = performance.now();
        const dt = now - this.animTimeLast;
        this.animClock += dt;
        this.animTimeLast = now;
        this.controls.update();

        // --- 1. Process Animations Queue ---
        const currentValues = new Map(); // Holds target values for this frame

        // Interpolate Baselines (e.g. return smile to 0 slowly)
        for (let [mt, x] of Object.entries(this.animBaseline)) {
          if (x.t0 === undefined) { x.t0 = this.animClock; x.v0 = this.getValue(mt); }
          const val = this.valueAnimationSeq([x.t0, x.t0 + 1000], [x.v0, x.target], this.animClock);
          currentValues.set(mt, val);
          if (this.animClock > x.t0 + 1000) delete this.animBaseline[mt];
        }

        // Process Active Queue Items
        for (let i = 0; i < this.animQueue.length; i++) {
          const anim = this.animQueue[i];

          // Not started yet
          if (this.animClock < anim.ts[0]) continue;

          // Calculate Values
          Object.entries(anim.vs).forEach(([mt, vs]) => {
            // Init start value if null (capture current state)
            if (vs[0] === null) vs[0] = this.getValue(mt) || 0;

            const val = this.valueAnimationSeq(anim.ts, vs, this.animClock);

            // Special Handling: Poses
            if (mt === 'pose') {
              // Only trigger once when the segment starts
              const segmentIdx = anim.ts.findIndex(t => t > this.animClock) - 1;
              const poseName = vs[Math.max(0, segmentIdx)];
              if (poseName && poseName !== this.currentPoseName && typeof poseName === 'string') {
                this.setPose(poseName);
              }
            }
            // Normal Handling: Morphs and Bones
            else {
              // Simple blending: keep the value with the highest magnitude 
              // (Prevents blink closing if eyes are wide, etc.)
              const prev = currentValues.get(mt) || 0;
              if (Math.abs(val) >= Math.abs(prev)) {
                currentValues.set(mt, val);
              }
            }
          });

          // Handle Finish / Loop
          if (this.animClock >= anim.ts.at(-1)) {
            if (anim.loop === -1) {
              // Re-queue infinite loops (like breathing) with new random delays
              this.animQueue[i] = this.animFactory(anim.template);
            } else {
              // Remove finished one-shots
              this.animQueue.splice(i--, 1);
            }
          }
        }

        // --- 2. Apply Morph Targets ---
        for (const mesh of this.morphs) {
          for (const name in mesh.morphTargetDictionary) {
            const idx = mesh.morphTargetDictionary[name];
            let val = currentValues.get(name);

            // Auto-decay if not explicit (return to neutral)
            if (val === undefined) {
              const curr = mesh.morphTargetInfluences[idx] || 0;
              if (name.startsWith('viseme_')) val = curr * 0.7; // Fast decay for speech
              else val = curr * 0.92; // Slow decay for expressions
            }
            mesh.morphTargetInfluences[idx] = Math.max(0, Math.min(1, val));
          }
        }

        // --- 3. Apply Bone Rotations (The "Alive" Movements) ---
        this.updatePoseBase(); // Interpolate the Base Pose (Standing/Relaxed)

        // Add Deltas (Breathing, Head Turning)
        const headX = currentValues.get('headRotateX') || 0;
        const headY = currentValues.get('headRotateY') || 0;
        const headZ = currentValues.get('headRotateZ') || 0;
        const chest = currentValues.get('chestInhale') || 0;
        const eyeX = currentValues.get('eyesRotateX') || 0;
        const eyeY = currentValues.get('eyesRotateY') || 0;

        // Update Delta Objects
        if (this.poseDelta.props['Head.rotation'])
          this.poseDelta.props['Head.rotation'].set(headX, headY, headZ);

        if (this.poseDelta.props['Spine1.rotation'])
          this.poseDelta.props['Spine1.rotation'].set(-chest * 0.05, 0, 0); // Chest puff rotates spine back

        // Apply Bone Transforms
        Object.keys(this.poseAvatar.props).forEach(key => {
          const boneObj = this.poseAvatar.props[key]; // The actual Three.js bone
          const baseObj = this.poseBase.props[key];   // The interpolated base pose

          if (boneObj.isQuaternion) {
            boneObj.copy(baseObj);

            // Add Delta if exists
            const [bName] = key.split('.');
            const deltaEuler = this.poseDelta.props[`${bName}.rotation`];
            if (deltaEuler) {
              const q = new THREE.Quaternion().setFromEuler(deltaEuler);
              boneObj.multiply(q);
            }
          } else if (boneObj.isVector3) {
            boneObj.copy(baseObj);
            // Add scale for chest breathing
            if (key === 'Spine1.scale' && chest > 0) {
              const s = 1 + (chest * 0.1);
              boneObj.set(s, s, s);
            }
          }
        });

        // Eye Rotation (Bone based)
        const lEye = this.armature.getObjectByName('LeftEye');
        const rEye = this.armature.getObjectByName('RightEye');
        if (lEye && rEye) {
          lEye.rotation.set(eyeX, eyeY, 0);
          rEye.rotation.set(eyeX, eyeY, 0);
        }

        this.renderer.render(this.scene, this.camera);
      }

      // --- HELPERS ---

      setPose(name, ms = 2000) {
        if (!this.poseTemplates[name]) return;
        this.currentPoseName = name;
        const template = this.poseTemplates[name];

        // Create target objects
        const newTargetProps = {};
        Object.keys(template.props).forEach(k => {
          const val = template.props[k];
          if (k.includes('rotation')) newTargetProps[k] = new THREE.Quaternion().setFromEuler(new THREE.Euler(val.x, val.y, val.z));
          else newTargetProps[k] = new THREE.Vector3(val.x, val.y, val.z);
        });

        // Update Pose Target
        this.poseTarget.props = newTargetProps;

        // Reset Timing for Base Interpolation
        Object.values(this.poseTarget.props).forEach(v => {
          v.t = this.animClock;
          v.d = ms;
        });
      }

      updatePoseBase() {
        // Linearly interpolate current Base towards Target
        for (const [key, targetVal] of Object.entries(this.poseTarget.props)) {
          const baseVal = this.poseBase.props[key];
          if (!baseVal) continue;

          const alpha = Math.min(1, (this.animClock - targetVal.t) / targetVal.d);
          if (alpha >= 1) {
            baseVal.copy(targetVal);
          } else {
            if (baseVal.isQuaternion) baseVal.slerp(targetVal, this.easing(alpha));
            else baseVal.lerp(targetVal, this.easing(alpha));
          }
        }
      }

      // --- SPEECH ---

      async processSpeechItem(item) {
        this.isSpeaking = true;

        if (item.type === 'text') {
          // TTS Call
          try {
            const pre = this.lipsync.en.preProcessText(item.content);
            const res = await fetch(this.opt.ttsEndpoint, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ text: pre })
            });
            if (!res.ok) throw new Error("TTS Error");
            const data = await res.json();
            await this.playAudioWithVisemes(data.audioContent, data.timepoints);
          } catch (e) {
            console.error(e);
            this.finishSpeaking();
          }

        } else if (item.type === 'emoji') {
          // Direct Emoji Animation
          const anim = this.animFactory(this.animEmojis[item.content] || this.animEmojis['ðŸ˜Š']);
          this.animQueue.push(anim);
          setTimeout(() => this.finishSpeaking(), anim.ts.at(-1) - this.animClock);
        }
      }

      async playAudioWithVisemes(base64, timepoints) {
        if (this.audioCtx.state === 'suspended') await this.audioCtx.resume();

        const audioData = Uint8Array.from(atob(base64), c => c.charCodeAt(0)).buffer;
        const buffer = await this.audioCtx.decodeAudioData(audioData);
        const durationMs = buffer.duration * 1000;

        // 1. ADD MICRO-EXPRESSIONS (The "Alive" part of speaking)
        // Randomly nod or raise eyebrows during speech chunks
        const numEmphases = Math.floor(durationMs / 2000); // Once every 2 seconds roughly
        for (let i = 0; i < numEmphases; i++) {
          const t = this.animClock + (Math.random() * durationMs);
          if (Math.random() > 0.5) {
            // Nod
            this.animQueue.push({ ts: [t, t + 150, t + 400], vs: { headRotateX: [0, 0.15, 0] } });
          } else {
            // Eyebrows
            this.animQueue.push({ ts: [t, t + 200, t + 600], vs: { browInnerUp: [0, 0.6, 0] } });
          }
        }

        // 2. MAP VISEMES
        const audioStart = this.animClock + 100; // Slight delay for buffer
        timepoints.forEach((tp, idx) => {
          const next = timepoints[idx + 1];
          // Estimate duration if next point missing
          const wordDur = next ? (next.time_seconds - tp.time_seconds) * 1000 : 200;

          const wordVisemes = this.lipsync.en.wordsToVisemes(tp.word);
          if (wordVisemes.visemes.length) {
            const totalRelDur = wordVisemes.durations.reduce((a, b) => a + b, 0);
            wordVisemes.visemes.forEach((v, i) => {
              const relStart = wordVisemes.times[i] / totalRelDur * wordDur;
              const relDur = wordVisemes.durations[i] / totalRelDur * wordDur;
              const t = audioStart + (tp.time_seconds * 1000) + relStart;

              // Push to queue
              this.animQueue.push({
                ts: [t, t + (relDur * 0.5), t + relDur],
                vs: { [`viseme_${v}`]: [0, 0.8, 0] } // 0.8 intensity
              });
            });
          }
        });

        // 3. Play Audio
        if (this.audioSpeechSource) this.audioSpeechSource.stop();
        this.audioSpeechSource = this.audioCtx.createBufferSource();
        this.audioSpeechSource.buffer = buffer;
        this.audioSpeechSource.connect(this.audioCtx.destination);
        this.audioSpeechSource.start(this.audioCtx.currentTime + 0.1);

        // Trigger subtitles if function exists globally
        if (typeof scheduleAISubtitles === 'function') {
          scheduleAISubtitles(timepoints, buffer.duration, this.audioCtx.currentTime + 0.1);
        }

        this.audioSpeechSource.onended = () => this.finishSpeaking();
      }

      // Utils
      speakText(t) {
        if (this.isSpeaking) { this.speechQueue.push({ type: 'text', content: t }); return; }
        this.processSpeechItem({ type: 'text', content: t });
      }
      speakEmoji(e) {
        if (this.isSpeaking) { this.speechQueue.push({ type: 'emoji', content: e }); return; }
        this.processSpeechItem({ type: 'emoji', content: this.animEmojis[e] });
      }
      finishSpeaking() {
        this.isSpeaking = false;
        this.startIdleBehavior();
        if (this.speechQueue.length) this.processSpeechItem(this.speechQueue.shift());
      }
      stopSpeaking() {
        if (this.audioSpeechSource) this.audioSpeechSource.stop();
        this.speechQueue = [];
        this.finishSpeaking();
      }
      getValue(name) {
        // Simplified getter for current Morph/Rotation state
        if (name.startsWith('headRotate')) {
          const axis = name.slice(-1).toLowerCase();
          return this.poseDelta.props['Head.rotation']?.[axis] || 0;
        }
        const mesh = this.morphs[0];
        return (mesh && mesh.morphTargetDictionary[name] !== undefined) ? mesh.morphTargetInfluences[mesh.morphTargetDictionary[name]] : 0;
      }
      onResize() {
        this.camera.aspect = this.nodeAvatar.clientWidth / this.nodeAvatar.clientHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(this.nodeAvatar.clientWidth, this.nodeAvatar.clientHeight);
      }
      setView(v) { this.camera.position.set(0, 1.55, 0.85); } // Close up for interview

      // Factory: Converts Template to Playable Animation
      animFactory(t) {
        const inst = { template: t, ts: [], vs: {}, loop: t.loop };

        // Random Delay
        let delay = 0;
        if (t.delay) delay = Array.isArray(t.delay) ? (t.delay[0] + Math.random() * (t.delay[1] - t.delay[0])) : t.delay;

        let curTime = this.animClock + delay;
        inst.ts.push(curTime);

        // Delta Times
        const dts = t.dt || [1000];
        dts.forEach(dt => {
          const step = Array.isArray(dt) ? (dt[0] + Math.random() * (dt[1] - dt[0])) : dt;
          curTime += step;
          inst.ts.push(curTime);
        });

        // Values
        Object.keys(t.vs).forEach(k => {
          const rawVals = t.vs[k];
          inst.vs[k] = rawVals.map(v => {
            if (Array.isArray(v)) return v[0] + Math.random() * (v[1] - v[0]);
            return v;
          });
          // Pad
          while (inst.vs[k].length < inst.ts.length) inst.vs[k].push(inst.vs[k].at(-1));
        });
        return inst;
      }

      valueAnimationSeq(ts, vs, t) {
        if (t <= ts[0]) return vs[0];
        if (t >= ts.at(-1)) return vs.at(-1);
        let i = ts.findIndex(time => time > t) - 1;
        if (i < 0) i = 0;
        const progress = (t - ts[i]) / (ts[i + 1] - ts[i]);
        const val = vs[i] + (vs[i + 1] - vs[i]) * this.easing(progress);
        return val;
      }
    }

    // --- GLOBAL VARIABLES (For UI Interaction) ---
    let avatar;
    let userStream;
    let isModelLoaded = false;
    let areSubtitlesOn = true;
    let interviewConfig = {};
    let messages = [];
    let isRecording = false;
    let speechRecognition;
    let isWaitingForAIResponse = false;
    let scores = [];

    // --- HELPERS (Sanitize) ---
    let EMOJI_CHAR, NON_TTS;
    try {
      EMOJI_CHAR = /[\p{Emoji_Presentation}\p{Extended_Pictographic}]/u;
      NON_TTS = /[^\p{L}\p{N}\p{P}\p{Z}\n\r\t]/gu;
    } catch {
      EMOJI_CHAR = /[\u{1F300}-\u{1FAFF}\u{2600}-\u{27BF}]/u;
      NON_TTS = /[^A-Za-z0-9\s.,!?;:'"()[\]{}<>@#$%^&*_\-+=/\\|~`]/g;
    }
    function extractEmojisAndSanitize(text = "") {
      const chars = Array.from(text);
      const emojis = [];
      const noEmoji = chars.map(ch => {
        if (EMOJI_CHAR.test(ch)) { emojis.push(ch); return ""; }
        return ch;
      }).join("");
      let clean = noEmoji.replace(NON_TTS, "").replace(/\s{2,}/g, " ").trim();
      return { clean, emojis };
    }
    function sanitizeForTTS(s) { return extractEmojisAndSanitize(s).clean; }

    // --- UI ELEMENTS ---
    const setupScreen = document.getElementById('setup-screen');
    const loadingScreen = document.getElementById('loading-screen');
    const permissionsModal = document.getElementById('permissions-modal');
    const interviewScreen = document.getElementById('interview-screen');
    const setupForm = document.getElementById('setup-form');
    const avatarContainer = document.getElementById('avatar-container');
    const modelLoadingOverlay = document.getElementById('model-loading-overlay');
    const chatMessages = document.getElementById('chat-messages');
    const userVideo = document.getElementById('user-video');
    const subtitlesOverlay = document.getElementById('subtitles-overlay');
    const currentRoleSpan = document.getElementById('current-role');
    const loadingProgressBar = document.getElementById('loading-progress-bar');
    const pushToTalkBtn = document.getElementById('push-to-talk-btn');
    const speechStatus = document.getElementById('speech-status');
    const scorePill = document.getElementById('score-pill');
    const progressPill = document.getElementById('progress-pill');
    const subtitlesBtn = document.getElementById('subtitles-btn');
    const endCallBtn = document.getElementById('end-call-btn');
    const allowPermissionsBtn = document.getElementById('allow-permissions');
    const skipPermissionsBtn = document.getElementById('skip-permissions');

    let interimTranscript = '';
    let finalTranscript = '';

    // --- INITIALIZATION ---
    async function init() {
      setupEventListeners();
      setupSpeechRecognition();
      loadModelInBackground();
      subtitlesBtn.classList.toggle('active', areSubtitlesOn);
    }

    function setupEventListeners() {
      setupForm.addEventListener('submit', handleSetupSubmit);
      subtitlesBtn.addEventListener('click', toggleSubtitles);
      endCallBtn.addEventListener('click', endInterview);

      if (allowPermissionsBtn) allowPermissionsBtn.addEventListener('click', requestPermissions);
      if (skipPermissionsBtn) skipPermissionsBtn.addEventListener('click', skipPermissions);

      pushToTalkBtn.addEventListener('mousedown', startRecording);
      pushToTalkBtn.addEventListener('mouseup', stopRecording);
      pushToTalkBtn.addEventListener('mouseleave', stopRecording);
      pushToTalkBtn.addEventListener('touchstart', startRecording, { passive: false });
      pushToTalkBtn.addEventListener('touchend', stopRecording);
      pushToTalkBtn.addEventListener('touchcancel', stopRecording);

      window.addEventListener('resize', () => {
        if (avatar) avatar.onResize();
      });
    }

    // --- SPEECH RECOGNITION ---
    function setupSpeechRecognition() {
      if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        speechRecognition = new SpeechRecognition();
        speechRecognition.continuous = true;
        speechRecognition.interimResults = true;
        speechRecognition.lang = 'en-US';

        speechRecognition.onstart = () => { updateSpeechStatus('Listening...', true); };
        speechRecognition.onresult = (event) => {
          interimTranscript = '';
          finalTranscript = '';
          for (let i = event.resultIndex; i < event.results.length; ++i) {
            if (event.results[i].isFinal) finalTranscript += event.results[i][0].transcript;
            else interimTranscript += event.results[i][0].transcript;
          }
          const display = (finalTranscript + ' ' + interimTranscript).trim();
          updateSpeechStatus(display ? `You said: ${display}` : 'Listening...', true);
          if (areSubtitlesOn && display) showSubtitles(`You: ${display}`);
        };
        speechRecognition.onend = () => {
          const toSend = (finalTranscript + ' ' + interimTranscript).trim();
          if (toSend && !isWaitingForAIResponse) {
            if (areSubtitlesOn) showSubtitles(`You: ${toSend}`);
            handleSpeechInput(toSend);
          }
          isRecording = false;
          pushToTalkBtn.classList.remove('recording');
          updateSpeechStatus('', false);
        };
      }
    }

    function startRecording(event) {
      if (event) event.preventDefault();
      if (isRecording || isWaitingForAIResponse) return;
      isRecording = true;
      pushToTalkBtn.classList.add('recording');
      interimTranscript = ''; finalTranscript = '';
      try { speechRecognition.start(); } catch (e) { }
    }

    function stopRecording(event) {
      if (event) event.preventDefault();
      if (!isRecording) return;
      try { speechRecognition.stop(); } catch (e) { }
    }

    function handleSpeechInput(transcript) {
      if (!transcript.trim() || isWaitingForAIResponse) return;
      addChatMessage('user', 'You', transcript);
      sendToAI(transcript);
    }

    function updateSpeechStatus(text, visible) {
      speechStatus.textContent = text;
      speechStatus.classList.toggle('visible', visible);
    }

    // --- LOADING ---
    async function loadModelInBackground() {
      try {
        avatar = new TalkingHead(avatarContainer, { ttsEndpoint: TTS_ENDPOINT, cameraView: 'head' });
        await avatar.init();
        avatar.onResize();

        updateLoadingProgress(30, 'Loading 3D model...');
        await avatar.showAvatar({ url: AVATAR_URL });

        updateLoadingProgress(100, 'Ready!');
        isModelLoaded = true;
        modelLoadingOverlay.classList.add('hidden');
        loadingScreen.classList.add('hidden');
        setTimeout(() => avatar && avatar.onResize(), 100);
      } catch (error) {
        console.error('Failed to load avatar:', error);
        updateLoadingProgress(0, 'Failed to load. Refresh page.');
      }
    }

    function updateLoadingProgress(percent, text) {
      loadingProgressBar.style.width = `${percent}%`;
      const lt = document.querySelector('.loading-text');
      if (lt) lt.textContent = text;
    }

    // --- FLOW CONTROL ---
    async function handleSetupSubmit(e) {
      e.preventDefault();
      interviewConfig = {
        specialization: document.getElementById('specialization').value,
        experienceLevel: document.getElementById('experience-level').value,
        companyType: document.getElementById('company-type').value,
        duration: document.getElementById('interview-duration').value
      };
      currentRoleSpan.textContent = interviewConfig.specialization;
      setupScreen.classList.add('hidden');

      if (!isModelLoaded) {
        loadingScreen.classList.remove('hidden');
        while (!isModelLoaded) await new Promise(r => setTimeout(r, 100));
        loadingScreen.classList.add('hidden');
      }
      try {
        const existing = await navigator.mediaDevices.getUserMedia({ video: false, audio: true });
        existing.getTracks().forEach(t => t.stop());
        skipPermissions();
      } catch (error) {
        permissionsModal.classList.remove('hidden');
      }
    }

    function skipPermissions() {
      permissionsModal.classList.add('hidden');
      startInterview();
    }
    async function requestPermissions() {
      try {
        await ensureUserMedia(true);
        skipPermissions();
      } catch (e) { skipPermissions(); }
    }

    async function ensureUserMedia(showVideo) {
      try {
        userStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: true });
        if (userVideo) { userVideo.srcObject = userStream; userVideo.play().catch(() => { }); }
      } catch (e) { }
    }

    async function startInterview() {
      interviewScreen.classList.remove('hidden');
      messages = [];
      isWaitingForAIResponse = false;
      await ensureUserMedia(true);
      setTimeout(() => avatar && avatar.onResize(), 50);

      const welcome = 'Hello! I\'m Alex. Ready to begin the interview?';
      addChatMessage('ai', 'Alex Johnson', welcome);
      if (avatar) avatar.speakText(welcome);
      if (areSubtitlesOn) showSubtitles(`Alex: ${welcome}`);
    }

    function addChatMessage(type, author, content) {
      const el = document.createElement('div');
      el.className = `message ${type}`;
      el.innerHTML = `<div class="message-author">${author}</div><div class="message-content">${content}</div>`;
      chatMessages.appendChild(el);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    // --- AI COMMUNICATION ---
    async function sendToAI(message) {
      if (isWaitingForAIResponse) return;
      isWaitingForAIResponse = true;
      try {
        messages.push({ role: 'user', content: message });
        const response = await fetch(WORKER_URL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Specialization': interviewConfig.specialization,
            'X-Experience-Level': interviewConfig.experienceLevel,
            'X-Company-Type': interviewConfig.companyType,
            'X-Duration': interviewConfig.duration
          },
          body: JSON.stringify({ messages })
        });
        const data = await response.json();
        if (data.ok && data.response) {
          let aiMessage = data.response;
          messages.push({ role: 'assistant', content: aiMessage });
          addChatMessage('ai', 'Alex Johnson', aiMessage);

          const { clean, emojis } = extractEmojisAndSanitize(aiMessage);

          if (avatar && isModelLoaded) {
            // Play animations based on extracted emojis
            emojis.forEach((e, i) => {
              setTimeout(() => avatar.speakEmoji(e), i * 500);
            });
            avatar.speakText(clean);
          }
          if (areSubtitlesOn) showSubtitles(`Alex: ${aiMessage}`);
        }
      } catch (error) {
        console.error(error);
        addChatMessage('ai', 'System', 'Connection error. Please try again.');
      } finally {
        isWaitingForAIResponse = false;
      }
    }

    // --- UI HELPERS ---
    function showSubtitles(text) {
      subtitlesOverlay.textContent = text;
      subtitlesOverlay.classList.remove('hidden');
      if (subtitlesOverlay._timer) clearTimeout(subtitlesOverlay._timer);
      subtitlesOverlay._timer = setTimeout(() => subtitlesOverlay.classList.add('hidden'), 4000);
    }

    // Global hook for the Class to call
    window.scheduleAISubtitles = function (timepoints, duration, startTime) {
      if (!areSubtitlesOn) return;
      const now = new Date();
      const timeStr = `[${now.getHours()}:${now.getMinutes()}]`;

      // Clear existing
      if (subtitlesOverlay._sched) subtitlesOverlay._sched.forEach(id => clearTimeout(id));
      subtitlesOverlay._sched = [];

      let sentence = [];
      timepoints.forEach(tp => {
        // Calculate delay: (Word Time - Current Time)
        const delay = (tp.time_seconds * 1000);

        subtitlesOverlay._sched.push(setTimeout(() => {
          sentence.push(tp.word);
          const display = sentence.slice(-8).join(' ');
          showSubtitles(`${timeStr} Alex: ${display}`);
          if (/[.!?]/.test(tp.word)) sentence = [];
        }, delay));
      });
    };

    function toggleSubtitles() {
      areSubtitlesOn = !areSubtitlesOn;
      subtitlesBtn.classList.toggle('active', areSubtitlesOn);
      if (!areSubtitlesOn) subtitlesOverlay.classList.add('hidden');
    }

    function endInterview() {
      if (confirm('End interview?')) {
        if (userStream) userStream.getTracks().forEach(t => t.stop());
        if (avatar) avatar.stopSpeaking();
        interviewScreen.classList.add('hidden');
        setupScreen.classList.remove('hidden');
        isModelLoaded = false;
        location.reload(); // Simplest reset
      }
    }

    init();
  </script>
  <script defer src='https://static.cloudflareinsights.com/beacon.min.js'
    data-cf-beacon='{"token": "9ecf6f49919940acb2efcc833483cd5f"}'></script><!-- Cloudflare Pages Analytics -->
  <script defer src='https://static.cloudflareinsights.com/beacon.min.js'
    data-cf-beacon='{"token": "9ecf6f49919940acb2efcc833483cd5f"}'></script><!-- Cloudflare Pages Analytics -->
</body>

</html>