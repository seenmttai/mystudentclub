<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Video Interview - Professional Practice Platform</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary: #4f46e5;
      --primary-light: #6366f1;
      --secondary: #6b7280;
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
      --bg-primary: #030712;
      --bg-secondary: #111827;
      --bg-tertiary: #1f2937;
      --text-primary: #f9fafb;
      --text-secondary: #d1d5db;
      --text-muted: #9ca3af;
      --border: #374151;
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
      --border-radius: 0.75rem;
      --transition: all 0.2s ease-in-out;
    }

    .hidden {
      display: none !important;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background-color: var(--bg-primary);
      background-image: radial-gradient(ellipse 80% 50% at 50% -20%, rgba(120, 119, 198, 0.3), transparent);
      color: var(--text-primary);
      min-height: 100vh;
      overflow-x: hidden;
    }

    .setup-container {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      position: relative;
    }

    .subtitles-overlay {
      position: absolute;
      left: 50%;
      bottom: 76px;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, .65);
      color: #fff;
      padding: .6rem .9rem;
      border-radius: 10px;
      font-size: 1rem;
      line-height: 1.35;
      max-width: 88%;
      text-align: center;
      z-index: 20;
      pointer-events: none;
      white-space: pre-wrap;
    }


    .setup-container::before {
      display: none;
    }

    .setup-card {
      background: rgba(17, 24, 39, 0.6);
      backdrop-filter: blur(24px);
      border: 1px solid transparent;
      background-clip: padding-box;
      border-image: linear-gradient(to bottom right, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05)) 1;
      border-radius: 24px;
      padding: 3rem;
      max-width: 600px;
      width: 100%;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      position: relative;
      z-index: 2;
    }

    .setup-header {
      text-align: center;
      margin-bottom: 2.5rem;
    }

    .setup-logo {
      width: 56px;
      height: 56px;
      background: linear-gradient(135deg, var(--primary), var(--primary-light));
      border-radius: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 1.5rem;
      box-shadow: 0 0 20px rgba(79, 70, 229, 0.4);
    }

    .setup-title {
      font-size: 2.25rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--text-primary), var(--text-secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 0.75rem;
    }

    .setup-subtitle {
      color: var(--text-muted);
      font-size: 1.1rem;
      line-height: 1.6;
      max-width: 450px;
      margin: 0 auto;
    }

    .form-grid {
      display: grid;
      gap: 1.5rem;
      margin-top: 2.5rem;
    }

    .form-group {
      display: flex;
      flex-direction: column;
    }

    .form-label {
      font-weight: 500;
      margin-bottom: 0.5rem;
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .form-input,
    .form-select {
      padding: 0.875rem 1rem;
      background: rgba(17, 24, 39, 0.8);
      border: 1px solid var(--border);
      border-radius: var(--border-radius);
      color: var(--text-primary);
      font-size: 1rem;
      transition: var(--transition);
    }

    .select-wrapper {
      position: relative;
      display: block;
    }

    .select-wrapper::after {
      content: "â–¾";
      position: absolute;
      right: 14px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--text-secondary);
      pointer-events: none;
      font-size: 0.95rem;
    }

    .form-select {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      color-scheme: dark;
      width: 100%;
      line-height: 1.2;
      cursor: pointer;

      background-color: var(--bg-secondary);
      color: var(--text-primary);
      border-color: var(--border);
    }

    .form-select:hover {
      background-color: #0b1220;
    }

    .form-select:focus {
      outline: none;
      border-color: var(--primary-light);
      background-color: #0b1220;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25);
    }


    .form-select option,
    .form-select optgroup {
      background-color: #0b1220 !important;
      color: #f9fafb !important;
    }

    .form-select option:checked,
    .form-select option:focus,
    .form-select option:hover {
      background-color: #1e40af !important;
      color: #ffffff !important;
    }


    @media (-ms-high-contrast: active) {
      .form-select {
        border: 2px solid windowText;
      }
    }


    .form-select::-webkit-scrollbar {
      width: 12px;
    }

    .form-select::-webkit-scrollbar-track {
      background: #0b1220;
    }

    .form-select::-webkit-scrollbar-thumb {
      background-color: #334155;
      border-radius: 8px;
      border: 3px solid #0b1220;
    }


    @-moz-document url-prefix() {

      .form-select,
      .form-select option,
      .form-select optgroup {
        background-color: #0b1220 !important;
        color: #f9fafb !important;
      }
    }

    .form-input:focus,
    .form-select:focus {
      outline: none;
      border-color: var(--primary-light);
      background: var(--bg-secondary);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
    }

    .btn {
      padding: 1rem 2rem;
      border: none;
      border-radius: var(--border-radius);
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      transition: var(--transition);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      position: relative;
      overflow: hidden;
    }

    .btn-primary {
      background-image: linear-gradient(to right, #4f46e5 0%, #7c3aed 50%, #4f46e5 100%);
      background-size: 200% auto;
      color: white;
      box-shadow: 0 4px 15px 0 rgba(79, 70, 229, 0.35);
    }

    .btn-primary:hover {
      background-position: right center;
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(79, 70, 229, 0.4);
    }

    .btn-primary:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }


    .loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--bg-primary);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .loading-spinner {
      width: 48px;
      height: 48px;
      border: 3px solid rgba(59, 130, 246, 0.2);
      border-top: 3px solid var(--primary-light);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 1.5rem;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    .loading-text {
      color: var(--text-secondary);
      font-size: 1.1rem;
      margin-bottom: 0.5rem;
    }

    .loading-progress {
      width: 200px;
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      overflow: hidden;
    }

    .loading-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--primary), var(--primary-light));
      width: 0%;
      transition: width 0.5s ease;
    }


    .interview-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--bg-primary);
      display: flex;
      flex-direction: column;
    }

    .interview-header {
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      padding: 1rem 2rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid var(--border);
      z-index: 10;
    }

    .interview-title {
      font-weight: 600;
      color: var(--text-primary);
    }

    .interview-controls {
      display: flex;
      gap: 1rem;
      margin-left: auto;
    }

    .control-btn {
      width: 40px;
      height: 40px;
      border: none;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-primary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: var(--transition);
    }

    .control-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .control-btn.active {
      background: var(--primary-light);
    }

    .control-btn.danger {
      background: var(--error);
    }

    .interview-main {
      flex: 1;
      display: grid;
      grid-template-columns: 1fr 340px;
      gap: 1rem;
      padding: 1rem;
      overflow: hidden;
      padding-bottom: 96px;
    }

    .main-video {
      background: var(--bg-secondary);
      border-radius: var(--border-radius);
      position: relative;
      overflow: hidden;
      min-height: 400px;
      border: 1px solid var(--border);
    }

    .avatar-container {
      width: 100%;
      height: 100%;
      position: relative;
    }

    .video-overlay {
      position: absolute;
      bottom: 1rem;
      left: 1rem;
      right: 1rem;
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      pointer-events: none;
    }

    .participant-info {
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      padding: 0.5rem 1rem;
      border-radius: 8px;
      color: white;
      font-size: 0.9rem;
      font-weight: 500;
    }

    .video-status {
      display: flex;
      gap: 0.5rem;
    }

    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--success);
      box-shadow: 0 0 8px var(--success);
    }

    .status-indicator.muted {
      background: var(--error);
      box-shadow: 0 0 8px var(--error);
    }

    .sidebar {
      width: 340px;
      background: var(--bg-secondary);
      border-radius: var(--border-radius);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      border: 1px solid var(--border);
    }

    .user-video {
      height: 180px;
      background: var(--bg-tertiary);
      position: relative;
      border-radius: var(--border-radius) var(--border-radius) 0 0;
      border-bottom: 1px solid var(--border);
    }

    .user-video video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .chat-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 1rem;
      overflow: hidden;
      min-height: 0;
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      margin-bottom: 1rem;
      max-height: 100%;
      scrollbar-width: thin;
    }

    .message {
      margin-bottom: 1rem;
      max-width: 90%;
    }

    .message.ai {
      align-self: flex-start;
    }

    .message.user {
      align-self: flex-end;
    }

    .message-author {
      font-weight: 600;
      font-size: 0.85rem;
      margin-bottom: 0.35rem;
      color: var(--text-secondary);
    }

    .message-content {
      padding: 0.75rem 1rem;
      border-radius: 12px;
      line-height: 1.5;
      color: var(--text-primary);
    }

    .message.ai .message-content {
      background: var(--bg-tertiary);
      border-top-left-radius: 2px;
    }

    .message.user .message-content {
      background: var(--primary);
      color: white;
      border-top-right-radius: 2px;
    }

    .chat-input-container {
      display: flex;
      gap: 0.5rem;
    }

    .chat-input {
      flex: 1;
      padding: 0.75rem;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 8px;
      color: var(--text-primary);
      resize: none;
      min-height: 40px;
      max-height: 100px;
    }

    .send-btn {
      width: 40px;
      height: 40px;
      background: var(--primary-light);
      border: none;
      border-radius: 8px;
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: var(--transition);
    }

    .send-btn:hover {
      background: var(--primary);
    }


    .push-to-talk-container {
      position: relative;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .push-to-talk-btn {
      width: 56px;
      height: 56px;
      border: 3px solid var(--primary-light);
      border-radius: 50%;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: var(--transition);
      font-size: 1.3rem;
      position: relative;
    }

    .push-to-talk-btn:hover {
      background: rgba(59, 130, 246, 0.1);
      border-color: var(--primary);
    }

    .push-to-talk-btn.recording {
      background: var(--error);
      border-color: var(--error);
      color: white;
      animation: pulse-recording 1.5s infinite;
    }

    @keyframes pulse-recording {
      0% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.05);
      }

      100% {
        transform: scale(1);
      }
    }

    .push-to-talk-hint {
      font-size: 0.85rem;
      color: var(--text-muted);
      margin-left: 0.5rem;
    }


    .speech-status {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      font-size: 0.8rem;
      white-space: nowrap;
      margin-bottom: 0.5rem;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .speech-status.visible {
      opacity: 1;
    }


    .interview-footer {
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(10px);
      padding: 1rem 2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      border-top: 1px solid var(--border);
    }

    .footer-controls {
      display: flex;
      gap: 1rem;
    }

    .footer-btn {
      width: 48px;
      height: 48px;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: var(--transition);
      font-size: 1.2rem;
    }

    .footer-btn.mic {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .footer-btn.mic.muted {
      background: var(--error);
      color: white;
    }

    .footer-btn.camera {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .footer-btn.camera.off {
      background: var(--error);
      color: white;
    }

    .footer-btn.end-call {
      background: var(--error);
      color: white;
    }

    .footer-btn.subtitles {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .footer-btn.subtitles.active {
      background: var(--primary-light);
      color: white;
    }


    @media (max-width: 768px) {
      .setup-card {
        padding: 2rem;
        margin: 1rem;
      }

      .setup-title {
        font-size: 2rem;
      }

      .interview-main {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto;
        padding-bottom: 108px;
      }

      .main-video {
        min-height: 260px;
        height: 55vh;
      }

      .sidebar {
        width: 100%;
        height: auto;
        max-height: calc(45vh - 8px);
        display: grid;
        grid-template-columns: 180px 1fr;
      }

      .user-video {
        width: 200px;
        height: 100%;
        border-radius: var(--border-radius) 0 0 var(--border-radius);
        flex-shrink: 0;
      }

      .chat-section {
        min-height: 140px;
        overflow: hidden;
      }

      .chat-messages {
        max-height: calc(45vh - 60px);
        overflow-y: auto;
      }

      .subtitles-overlay {
        bottom: 96px;
        font-size: 0.9rem;
        max-width: 92%;
      }
    }

    @media (max-width: 480px) {
      .sidebar {
        grid-template-columns: 140px 1fr;
      }

      .main-video {
        min-height: 240px;
        height: 52vh;
      }
    }


    .floating-ptt {
      position: fixed;
      right: 16px;
      bottom: 88px;
      z-index: 1100;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      pointer-events: none;
    }

    .floating-ptt .push-to-talk-container {
      pointer-events: auto;
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.1);
      padding: 8px 10px;
      border-radius: 14px;
      backdrop-filter: blur(8px);
    }

    @media (max-width: 768px) {
      .floating-ptt {
        bottom: 96px;
        right: 12px;
      }
    }

    /* hide self camera on mobile and simplify sidebar layout */
    @media (max-width: 768px) {
      .user-video {
        display: none;
      }

      .sidebar {
        width: 100%;
        grid-template-columns: 1fr;
      }
    }

    /* Hide mobile chat UI by default (desktop), show only on mobile */
    @media (min-width: 769px) {

      #mobile-chat-fab,
      #mobile-chat-sheet {
        display: none;
      }
    }

    @media (max-width: 768px) {
      .mobile-chat-fab {
        position: fixed;
        right: 16px;
        bottom: 156px;
        background: #111827;
        color: #fff;
        border: 1px solid rgba(255, 255, 255, .12);
        padding: .6rem .9rem;
        border-radius: 999px;
        box-shadow: var(--shadow);
        z-index: 1200;
        display: inline-flex;
        align-items: center;
      }

      .mobile-chat-sheet {
        position: fixed;
        left: 0;
        right: 0;
        bottom: -100%;
        height: 70vh;
        background: #0f172a;
        border-top: 1px solid var(--border);
        border-radius: 16px 16px 0 0;
        display: flex;
        flex-direction: column;
        transition: transform .25s ease;
        transform: translateY(100%);
        z-index: 1300;
      }

      /* Ensure visibility on mobile */
      #mobile-chat-fab {
        display: inline-flex !important;
        z-index: 2000;
      }

      #mobile-chat-sheet {
        display: flex !important;
        z-index: 2100;
      }
    }
  </style>
  <script type="importmap">
    { 
      "imports": { 
        "three": "https://unpkg.com/three@0.149.0/build/three.module.js", 
        "three/addons/": "https://unpkg.com/three@0.149.0/examples/jsm/",
        "lipsync-en": "https://cdn.jsdelivr.net/gh/met4citizen/TalkingHead@1.2/modules/lipsync-en.mjs"
      } 
    }
    </script>
</head>

<body>

  <div id="setup-screen" class="setup-container">
    <div class="setup-card fade-in">
      <div class="setup-header">
        <div class="setup-logo">
          <svg width="32" height="32" viewBox="0 0 24 24" fill="white">
            <path
              d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z" />
          </svg>
        </div>
        <h1 class="setup-title">AI Video Interview</h1>
        <p class="setup-subtitle">Practice with our AI interviewer and get instant feedback on your performance</p>
      </div>

      <form id="setup-form" class="form-grid">
        <div class="form-group">
          <label class="form-label" for="specialization">Target Role</label>
          <div class="select-wrapper">
            <select id="specialization" class="form-select">
              <optgroup label="CA & Accounting (Recommended)">
                <option value="Chartered Accountant - Audit" selected>Chartered Accountant â€” Audit</option>
                <option value="Chartered Accountant - Taxation">Chartered Accountant â€” Taxation</option>
                <option value="Management Accountant (CMA)">Management Accountant (CMA)</option>
                <option value="Financial Controller">Financial Controller</option>
                <option value="Statutory Auditor">Statutory Auditor</option>
                <option value="IFRS Specialist">IFRS Specialist</option>
                <option value="GST/Indirect Tax Specialist">GST / Indirect Tax Specialist</option>
                <option value="Direct Tax Consultant">Direct Tax Consultant</option>
                <option value="Risk & Compliance (SOX/ICFR)">Risk & Compliance (SOX / ICFR)</option>
                <option value="Treasury Analyst">Treasury Analyst</option>
                <option value="Corporate Finance Associate">Corporate Finance Associate</option>
                <option value="Forensic Accountant">Forensic Accountant</option>
              </optgroup>
              <optgroup label="Other Roles">
                <option value="Finance Analyst">Finance Analyst</option>
                <option value="Business Analyst">Business Analyst</option>
                <option value="Product Manager">Product Manager</option>
                <option value="Data Scientist">Data Scientist</option>
                <option value="Software Engineer">Software Engineer</option>
                <option value="UX Designer">UX Designer</option>
                <option value="Marketing Manager">Marketing Manager</option>
                <option value="Sales Representative">Sales Representative</option>
              </optgroup>
            </select>
          </div>
        </div>

        <div class="form-group">
          <label class="form-label" for="experience-level">Experience Level</label>
          <div class="select-wrapper">
            <select id="experience-level" class="form-select">
              <option value="Article/Intern">Article/Intern</option>
              <option value="Entry Level" selected>Entry Level (0-2 years)</option>
              <option value="Mid Level">Mid Level (3-5 years)</option>
              <option value="Senior Level">Senior Level (6-10 years)</option>
              <option value="Executive Level">Executive Level (10+ years)</option>
            </select>
          </div>
        </div>

        <div class="form-group">
          <label class="form-label" for="company-type">Company Type</label>
          <div class="select-wrapper">
            <select id="company-type" class="form-select">
              <option value="Big 4 (Audit/Tax)">Big 4 (Audit/Tax)</option>
              <option value="Mid-size CA Firm">Mid-size CA Firm</option>
              <option value="Corporate (Industry)">Corporate (Industry)</option>
              <option value="Consulting Firm">Consulting Firm</option>
              <option value="Fortune 500">Fortune 500</option>
              <option value="Tech Startup">Tech Startup</option>
              <option value="Healthcare">Healthcare</option>
              <option value="Government">Government</option>
              <option value="Non-Profit">Non-Profit</option>
              <option value="Investment Bank">Investment Bank</option>
            </select>
          </div>
        </div>

        <div class="form-group">
          <label class="form-label" for="interview-duration">Interview Duration</label>
          <div class="select-wrapper">
            <select id="interview-duration" class="form-select">
              <option value="15">15 minutes</option>
              <option value="30" selected>30 minutes</option>
              <option value="45">45 minutes</option>
              <option value="60">60 minutes</option>
            </select>
          </div>
        </div>

        <button type="submit" class="btn btn-primary">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <path d="M8 5v14l11-7z" />
          </svg>
          Start Interview
        </button>
      </form>
    </div>
  </div>


  <div id="loading-screen" class="loading-screen hidden">
    <div class="loading-spinner"></div>
    <div class="loading-text">Preparing your interview...</div>
    <div class="loading-progress">
      <div class="loading-progress-bar" id="loading-progress-bar"></div>
    </div>
  </div>


  <div id="permissions-modal" class="permissions-modal hidden">
    <div class="permissions-content">
      <h2 class="permissions-title">Camera & Microphone Access</h2>
      <p class="permissions-text">
        To provide the best interview experience, we need access to your camera and microphone.
        This helps our AI interviewer analyze your verbal and non-verbal communication.
      </p>
      <div class="permissions-actions">
        <button id="allow-permissions" class="btn btn-primary">Allow Access</button>
        <button id="skip-permissions" class="btn"
          style="background: var(--bg-tertiary); color: var(--text-primary);">Skip for now</button>
      </div>
    </div>
  </div>


  <div id="interview-screen" class="interview-container hidden">
    <header class="interview-header">
      <div class="interview-title">
        AI Video Interview - <span id="current-role">Software Engineer</span>
        <span class="pills">
          <span id="score-pill" class="pill success">Avg Score: â€”</span>
          <span id="progress-pill" class="pill info">Progress: 0%</span>
        </span>
      </div>
      <div class="interview-controls">
      </div>
    </header>

    <main class="interview-main">
      <div class="main-video">
        <div id="avatar-container" class="avatar-container">
          <div id="model-loading-overlay" class="model-loading-overlay">
            <div class="loading-spinner"></div>
            <div style="color: var(--text-secondary); margin-top: 1rem;">Loading AI Interviewer...</div>
          </div>
        </div>
        <div class="video-overlay">
          <div class="participant-info">
            Alex Johnson - AI Interviewer
          </div>
          <div class="video-status">
            <div class="status-indicator" id="ai-audio-status"></div>
          </div>
        </div>
        <div id="subtitles-overlay" class="subtitles-overlay hidden"></div>
      </div>

      <aside class="sidebar">
        <div class="user-video">
          <video id="user-video" autoplay muted playsinline></video>
          <div class="video-overlay" style="bottom: 0.5rem; left: 0.5rem; right: 0.5rem;">
            <div class="participant-info" style="font-size: 0.8rem;">
              You
            </div>
            <div class="video-status">
              <div class="status-indicator" id="user-audio-status"></div>
            </div>
          </div>
        </div>

        <div class="chat-section">
          <div id="chat-messages" class="chat-messages"></div>
        </div>
      </aside>
    </main>

    <footer class="interview-footer">
      <div class="footer-controls">
        <button id="subtitles-btn" class="footer-btn subtitles" title="Toggle Subtitles">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <path
              d="M19 4H5c-1.66 0-3.15.25-4.6.72v3.1c0 .39-.23.74-.56.9-.98.49-1.87 1.12-2.66 1.85-.18.18-.43.28-.7.28-.28 0-.53-.11-.71-.29L.29 13.08c-.18-.17-.29-.42-.29-.7 0-.28.11-.53.29-.71C3.34 8.78 7.46 7 12 7s8.66 1.78 11.71 4.67c.18.18.29.43.29.71 0 .28-.11.53-.29.71l-2.48 2.48c-.18.18-.43.29-.71.29-.79-.73-1.68-1.36-2.66-1.85-.33-.16-.56-.51-.56-.9v-3.1C15.15 9.25 13.6 9 12 9z" />
          </svg>
        </button>
        <button id="end-call-btn" class="footer-btn end-call" title="End Interview">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <path
              d="M12 9c-1.66 0-3.15.25-4.6.72v3.1c0 .39-.23.74-.56.9-.98.49-1.87 1.12-2.66 1.85-.18.18-.43.28-.7.28-.28 0-.53-.11-.71-.29L.29 13.08c-.18-.17-.29-.42-.29-.7 0-.28.11-.53.29-.71C3.34 8.78 7.46 7 12 7s8.66 1.78 11.71 4.67c.18.18.29.43.29.71 0 .28-.11.53-.29.71l-2.48 2.48c-.18.18-.43.29-.71.29-.79-.73-1.68-1.36-2.66-1.85-.33-.16-.56-.51-.56-.9v-3.1C15.15 9.25 13.6 9 12 9z" />
          </svg>
        </button>
      </div>
    </footer>


    <div class="floating-ptt" aria-live="polite">
      <div class="push-to-talk-container">
        <button id="push-to-talk-btn" class="push-to-talk-btn" title="Hold to speak" aria-label="Hold to speak">
          <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
            <path
              d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.49 6-3.31 6-6.72h-1.7z" />
          </svg>
        </button>
        <div id="speech-status" class="speech-status" role="status" aria-live="polite"></div>
        <span class="push-to-talk-hint">Hold to speak, release to send</span>
      </div>
    </div>

    <div id="mobile-chat-fab" class="mobile-chat-fab" aria-label="Open chat">Chat</div>
    <div id="mobile-chat-sheet" class="mobile-chat-sheet" aria-hidden="true">
      <div class="sheet-header">
        <span>Chat</span>
        <button id="mobile-chat-close" class="sheet-close" aria-label="Close">Ã—</button>
      </div>
      <div id="mobile-chat-messages" class="sheet-messages"></div>
      <div class="sheet-input">
        <input id="mobile-chat-input" type="text" placeholder="Type your message..." />
        <button id="mobile-send-btn" class="btn btn-primary">Send</button>
      </div>
    </div>
  </div>


  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
    import { LipsyncEn } from 'lipsync-en';
    // Import new extended animations
    import { poses, moods, emojis, gestures } from 'https://www.mystudentclub.com/scripts/animations.js';

    // --- CONFIGURATION ---
    const AVATAR_URL = 'https://models.readyplayer.me/69440c84ca696e5f2fb7bfd5.glb?morphTargets=ARKit,Oculus+Visemes,mouthOpen,mouthSmile,eyesClosed,eyesLookUp,eyesLookDown';
    const WORKER_URL = 'https://interviewme.bhansalimanan55.workers.dev/';
    const TTS_ENDPOINT = 'https://us-central1-msc-notif.cloudfunctions.net/gcp-tts-rate-limited';

    // --- TALKING HEAD CLASS ---
    class TalkingHead {
      constructor(node, opt = {}) {
        this.nodeAvatar = node;
        this.opt = { ttsEndpoint: null, lipsyncLang: 'en', cameraView: 'upper', ...opt };

        // Three.js Setup
        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(node.clientWidth, node.clientHeight);
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.nodeAvatar.appendChild(this.renderer.domElement);

        this.camera = new THREE.PerspectiveCamera(25, node.clientWidth / node.clientHeight, 0.1, 100);
        this.scene = new THREE.Scene();

        // Lighting
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.7);
        hemiLight.position.set(0, 20, 0);
        this.scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(0.5, 2, 2);
        dirLight.castShadow = true;
        this.scene.add(dirLight);

        this.controls = new OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableZoom = false;
        this.controls.enablePan = false;
        this.controls.target.set(0, 1.58, 0);
        this.controls.enableDamping = true;

        // State
        this.animClock = 0;
        this.animTimeLast = 0;
        this.avatar = null;
        this.armature = null;
        this.morphs = [];
        this.mixer = null;
        this.speechQueue = [];
        this.isSpeaking = false;
        this.isRunning = false;
        this.stateName = 'idle';
        this.currentAudioDuration = 0;

        this.audioCtx = new AudioContext();
        this.audioSpeechSource = null;
        this.lipsync = {};
        this.visemeNames = ['viseme_sil', 'viseme_PP', 'viseme_FF', 'viseme_TH', 'viseme_DD', 'viseme_kk', 'viseme_CH', 'viseme_SS', 'viseme_nn', 'viseme_RR', 'viseme_aa', 'viseme_E', 'viseme_I', 'viseme_O', 'viseme_U'];

        // Animation Data
        this.poseTemplates = poses;
        this.animMoods = moods;
        this.animEmojis = emojis;
        this.gestureTemplates = gestures || {};

        this.animQueue = [];
        this.easing = t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

        // Transform Objects
        this.poseBase = { props: {} };
        this.poseTarget = { props: {} };
        this.poseAvatar = { props: {} };
        this.poseDelta = { props: {} };
        this.animBaseline = {};
        this.currentPoseName = 'straight';

        window.addEventListener('resize', this.onResize.bind(this));
      }

      async init() {
        this.lipsync[this.opt.lipsyncLang] = new LipsyncEn();
        const rgbe = new RGBELoader();
        try {
          const tex = await new Promise((res, rej) => rgbe.load('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_09_1k.hdr', res, undefined, rej));
          tex.mapping = THREE.EquirectangularReflectionMapping;
          this.scene.environment = tex;
        } catch (e) { }
      }

      async showAvatar(avatar) {
        const loader = new GLTFLoader();
        const gltf = await loader.loadAsync(avatar.url);
        this.armature = gltf.scene;

        this.armature.traverse(node => {
          if (node.isMesh) {
            node.castShadow = true; node.receiveShadow = true; node.frustumCulled = false;
            if (node.material) {
              node.material.transparent = false; node.material.alphaTest = 0.5; node.material.side = THREE.FrontSide;
              if (node.name.toLowerCase().includes('eye')) { node.material.roughness = 0.2; node.material.metalness = 0.1; }
            }
            if (node.morphTargetDictionary) this.morphs.push(node);
          }
        });

        // Init Bones
        this.poseAvatar = { props: {} };
        this.poseDelta = { props: {} };
        if (!this.poseTemplates.straight) this.poseTemplates.straight = { props: {} }; // Safety

        // Setup Initial Pose
        this.poseBase = this.poseFactory(this.poseTemplates.straight);
        this.poseTarget = this.poseFactory(this.poseTemplates.straight);

        // Map all potential bones
        const usedBones = new Set();
        [...Object.values(this.poseTemplates), ...Object.values(this.gestureTemplates)].forEach(t => {
          if (t.props) Object.keys(t.props).forEach(k => usedBones.add(k));
          else Object.keys(t).forEach(k => usedBones.add(k)); // Gestures might be flat
        });

        usedBones.forEach(key => {
          const [boneName, prop] = key.split('.');
          const bone = this.armature.getObjectByName(boneName);
          if (bone) {
            this.poseAvatar.props[key] = bone[prop];
            if (!this.poseBase.props[key]) this.poseBase.props[key] = bone[prop].clone();
            if (!this.poseTarget.props[key]) this.poseTarget.props[key] = bone[prop].clone();

            if (prop === 'rotation' || prop === 'quaternion') this.poseDelta.props[key] = new THREE.Euler();
            else this.poseDelta.props[key] = new THREE.Vector3();
          }
        });

        this.setPose('straight', 0);
        this.scene.add(this.armature);
        this.setView(this.opt.cameraView);
        this.start();
      }

      // --- ANIMATION CORE ---
      start() {
        if (this.isRunning) return;
        this.isRunning = true;
        this.animTimeLast = performance.now();
        this.setMood('stern'); // Default to stern
        this.renderer.setAnimationLoop(this.animate.bind(this));
      }

      setMood(moodName) {
        if (!this.animMoods[moodName]) return;
        this.animQueue = this.animQueue.filter(a => a.loop !== -1); // Clear old idle
        this.animMoods[moodName].anims.forEach(anim => {
          this.animQueue.push(this.animFactory(anim));
        });
        // Set baseline morphs
        if (this.animMoods[moodName].baseline) {
          Object.entries(this.animMoods[moodName].baseline).forEach(([k, v]) => {
            this.animBaseline[k] = { target: v, t0: this.animClock, v0: this.getValue(k) };
          });
        }
      }

      animate() {
        const now = performance.now();
        const dt = now - this.animTimeLast;
        this.animClock += dt;
        this.animTimeLast = now;
        this.controls.update();

        const currentValues = new Map();

        // Baselines
        for (let [mt, x] of Object.entries(this.animBaseline)) {
          if (x.t0 === undefined) { x.t0 = this.animClock; x.v0 = this.getValue(mt); }
          const val = this.valueAnimationSeq([x.t0, x.t0 + 1000], [x.v0, x.target], this.animClock);
          currentValues.set(mt, val);
        }

        // Queue
        for (let i = 0; i < this.animQueue.length; i++) {
          const anim = this.animQueue[i];
          if (this.animClock < anim.ts[0]) continue;

          Object.entries(anim.vs).forEach(([mt, vs]) => {
            if (vs[0] === null) vs[0] = this.getValue(mt) || 0;
            const val = this.valueAnimationSeq(anim.ts, vs, this.animClock);

            if (mt === 'pose') {
              // Pose Switching
              const segmentIdx = anim.ts.findIndex(t => t > this.animClock) - 1;
              const poseName = vs[Math.max(0, segmentIdx)];
              if (poseName && poseName !== this.currentPoseName && typeof poseName === 'string') {
                this.setPose(poseName);
              }
            } else if (mt === 'gesture') {
              // Complex Gestures
              const segmentIdx = anim.ts.findIndex(t => t > this.animClock) - 1;
              const gData = vs[Math.max(0, segmentIdx)];
              if (Array.isArray(gData) && !anim._triggered) {
                this.playGesture(gData[0], gData[1]);
                anim._triggered = true; // prevent re-triggering in loop
              }
            } else {
              const prev = currentValues.get(mt) || 0;
              if (Math.abs(val) >= Math.abs(prev)) currentValues.set(mt, val);
            }
          });

          if (this.animClock >= anim.ts.at(-1)) {
            if (anim.loop === -1) {
              this.animQueue[i] = this.animFactory(anim.template); // Reset loop
            } else {
              this.animQueue.splice(i--, 1);
            }
          }
        }

        this.applyValues(currentValues);
        this.updatePoseBase();
        this.renderer.render(this.scene, this.camera);
      }

      applyValues(values) {
        // Morphs
        for (const mesh of this.morphs) {
          for (const name in mesh.morphTargetDictionary) {
            const idx = mesh.morphTargetDictionary[name];
            let val = values.get(name);
            if (val === undefined) {
              const curr = mesh.morphTargetInfluences[idx] || 0;
              // Fast decay for visemes, slow for others
              val = name.startsWith('viseme_') ? 0 : curr * 0.9;
            }
            mesh.morphTargetInfluences[idx] = Math.max(0, Math.min(1, val));
          }
        }

        // Bone Deltas
        const headX = values.get('headRotateX') || 0;
        const headY = values.get('headRotateY') || 0;
        const headZ = values.get('headRotateZ') || 0;
        const chest = values.get('chestInhale') || 0;
        const eyeX = values.get('eyesRotateX') || 0;
        const eyeY = values.get('eyesRotateY') || 0;

        if (this.poseDelta.props['Head.rotation']) this.poseDelta.props['Head.rotation'].set(headX, headY, headZ);
        if (this.poseDelta.props['Spine1.rotation']) this.poseDelta.props['Spine1.rotation'].set(-chest * 0.05, 0, 0);

        Object.keys(this.poseAvatar.props).forEach(key => {
          const boneObj = this.poseAvatar.props[key];
          const baseObj = this.poseBase.props[key];
          if (!boneObj || !baseObj) return;

          if (boneObj.isQuaternion) {
            boneObj.copy(baseObj);
            const [bName] = key.split('.');
            const deltaEuler = this.poseDelta.props[`${bName}.rotation`];
            if (deltaEuler) boneObj.multiply(new THREE.Quaternion().setFromEuler(deltaEuler));
          } else if (boneObj.isVector3) {
            boneObj.copy(baseObj);
            if (key === 'Spine1.scale' && chest > 0) boneObj.set(1 + (chest * 0.1), 1 + (chest * 0.1), 1 + (chest * 0.1));
          }
        });

        // Eyes
        const lEye = this.armature.getObjectByName('LeftEye');
        const rEye = this.armature.getObjectByName('RightEye');
        if (lEye && rEye) { lEye.rotation.set(eyeX, eyeY, 0); rEye.rotation.set(eyeX, eyeY, 0); }
      }

      // --- ANIMATION HELPERS ---
      setPose(name, ms = 2000) {
        if (!this.poseTemplates[name]) return;
        this.currentPoseName = name;
        const template = this.poseTemplates[name];
        const newTargetProps = {};
        Object.keys(template.props).forEach(k => {
          const val = template.props[k];
          if (k.includes('rotation')) newTargetProps[k] = new THREE.Quaternion().setFromEuler(new THREE.Euler(val.x, val.y, val.z));
          else newTargetProps[k] = new THREE.Vector3(val.x, val.y, val.z);
        });
        this.poseTarget.props = newTargetProps;
        Object.values(this.poseTarget.props).forEach(v => { v.t = this.animClock; v.d = ms; });
      }

      playGesture(name, dur = 1) {
        const g = this.gestureTemplates[name];
        if (!g) return;
        // Temporarily override target pose with gesture
        Object.keys(g).forEach(k => {
          const val = g[k];
          const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(val.x, val.y, val.z));
          if (this.poseTarget.props[k]) {
            this.poseTarget.props[k].copy(q);
            this.poseTarget.props[k].t = this.animClock;
            this.poseTarget.props[k].d = 500; // Fast in
          }
        });
        // Reset after duration
        setTimeout(() => {
          this.setPose(this.currentPoseName, 1000);
        }, dur * 1000);
      }

      updatePoseBase() {
        for (const [key, targetVal] of Object.entries(this.poseTarget.props)) {
          const baseVal = this.poseBase.props[key];
          if (!baseVal) continue;
          const alpha = Math.min(1, (this.animClock - targetVal.t) / targetVal.d);
          if (alpha >= 1) baseVal.copy(targetVal);
          else {
            if (baseVal.isQuaternion) baseVal.slerp(targetVal, this.easing(alpha));
            else baseVal.lerp(targetVal, this.easing(alpha));
          }
        }
      }

      // --- SPEECH & AUDIO ---
      async processSpeechItem(item) {
        this.isSpeaking = true;
        if (item.type === 'text') {
          try {
            const pre = this.lipsync.en.preProcessText(item.content);
            const res = await fetch(this.opt.ttsEndpoint, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ text: pre }) });
            if (!res.ok) throw new Error("TTS Error");
            const data = await res.json();
            await this.playAudioWithVisemes(data.audioContent, data.timepoints);
          } catch (e) { console.error(e); this.finishSpeaking(); }
        } else if (item.type === 'emoji') {
          const anim = this.animFactory(this.animEmojis[item.content] || this.animEmojis['ðŸ˜Š']);
          this.animQueue.push(anim);
          setTimeout(() => this.finishSpeaking(), anim.ts.at(-1) - this.animClock);
        }
      }

      async playAudioWithVisemes(base64, timepoints) {
        if (this.audioCtx.state === 'suspended') await this.audioCtx.resume();

        // Clean queue of old visemes
        this.animQueue = this.animQueue.filter(a => !Object.keys(a.vs)[0].startsWith('viseme_'));

        const audioData = Uint8Array.from(atob(base64), c => c.charCodeAt(0)).buffer;
        const buffer = await this.audioCtx.decodeAudioData(audioData);
        this.currentAudioDuration = buffer.duration;

        // 1. Strict Lip Sync (No Flapping)
        const audioStart = this.animClock + 50;
        timepoints.forEach((tp, idx) => {
          const nextTp = timepoints[idx + 1];
          const wordStart = tp.time_seconds * 1000;
          // Strict bounding: Word ends when next word begins
          const wordEnd = nextTp ? (nextTp.time_seconds * 1000) : (buffer.duration * 1000);
          const duration = wordEnd - wordStart;

          const vis = this.lipsync.en.wordsToVisemes(tp.word);
          if (vis.visemes.length) {
            const totalRel = vis.durations.reduce((a, b) => a + b, 0);
            vis.visemes.forEach((v, i) => {
              // Map relative viseme time to absolute audio time
              const absStart = wordStart + (vis.times[i] / totalRel * duration);
              const absDur = (vis.durations[i] / totalRel * duration);

              // Clamp minimum duration for visibility, but don't overlap too much
              const finalDur = Math.max(50, absDur);
              const t = audioStart + absStart;

              this.animQueue.push({
                ts: [t, t + (finalDur * 0.2), t + finalDur], // Attack, Sustain, Decay
                vs: { [`viseme_${v}`]: [0, 1, 0] } // Full intensity (1), then 0. No lingering.
              });
            });
          }
        });

        // 2. Play Audio
        if (this.audioSpeechSource) this.audioSpeechSource.stop();
        this.audioSpeechSource = this.audioCtx.createBufferSource();
        this.audioSpeechSource.buffer = buffer;
        this.audioSpeechSource.connect(this.audioCtx.destination);
        this.audioSpeechSource.start(this.audioCtx.currentTime + 0.05);

        // 3. Subtitles
        if (typeof scheduleAISubtitles === 'function') scheduleAISubtitles(timepoints, buffer.duration, this.audioCtx.currentTime + 0.05);

        this.audioSpeechSource.onended = () => this.finishSpeaking();
      }

      // Interrupt Handling
      interrupt() {
        if (!this.isSpeaking) return;
        if (this.audioSpeechSource) {
          this.audioSpeechSource.stop();
          this.audioSpeechSource = null;
        }
        // Clear visemes immediately
        this.animQueue = this.animQueue.filter(a => !Object.keys(a.vs)[0].startsWith('viseme_'));
        // Clear subtitle timers
        if (window.clearAISubtitles) window.clearAISubtitles();

        this.speechQueue = [];
        this.isSpeaking = false;
        this.stateName = 'idle';

        // Visually react to interruption
        this.speakEmoji('ðŸ˜¤');
      }

      speakText(t) { if (this.isSpeaking) { this.speechQueue.push({ type: 'text', content: t }); return; } this.processSpeechItem({ type: 'text', content: t }); }
      speakEmoji(e) { if (this.isSpeaking) { this.speechQueue.push({ type: 'emoji', content: e }); return; } this.processSpeechItem({ type: 'emoji', content: this.animEmojis[e] }); }
      finishSpeaking() { this.isSpeaking = false; this.startIdleBehavior(); if (this.speechQueue.length) this.processSpeechItem(this.speechQueue.shift()); }
      stopSpeaking() { this.interrupt(); }

      // Boilerplate
      getValue(n) { if (n.startsWith('headRotate')) return this.poseDelta.props['Head.rotation']?.[n.slice(-1).toLowerCase()] || 0; const m = this.morphs[0]; return (m && m.morphTargetDictionary[n] !== undefined) ? m.morphTargetInfluences[m.morphTargetDictionary[n]] : 0; }
      poseFactory(t, ms = 2000) { const p = {}; if (t.props) Object.keys(t.props).forEach(k => { const v = t.props[k]; if (k.includes('rotation')) p[k] = new THREE.Quaternion().setFromEuler(new THREE.Euler(v.x, v.y, v.z)); else p[k] = new THREE.Vector3(v.x, v.y, v.z); }); return { props: p }; }
      animFactory(t) { const i = { template: t, ts: [], vs: {}, loop: t.loop }; let c = this.animClock + (Array.isArray(t.delay) ? (t.delay[0] + Math.random() * (t.delay[1] - t.delay[0])) : (t.delay || 0)); i.ts.push(c); (t.dt || [1000]).forEach(d => { c += Array.isArray(d) ? (d[0] + Math.random() * (d[1] - d[0])) : d; i.ts.push(c); }); Object.keys(t.vs).forEach(k => { i.vs[k] = t.vs[k].map(v => Array.isArray(v) ? v[0] + Math.random() * (v[1] - v[0]) : v); while (i.vs[k].length < i.ts.length) i.vs[k].push(i.vs[k].at(-1)); }); return i; }
      valueAnimationSeq(ts, vs, t) { if (t <= ts[0]) return vs[0]; if (t >= ts.at(-1)) return vs.at(-1); let i = ts.findIndex(time => time > t) - 1; if (i < 0) i = 0; const p = (t - ts[i]) / (ts[i + 1] - ts[i]); return vs[i] + (vs[i + 1] - vs[i]) * this.easing(p); }
      onResize() { this.camera.aspect = this.nodeAvatar.clientWidth / this.nodeAvatar.clientHeight; this.camera.updateProjectionMatrix(); this.renderer.setSize(this.nodeAvatar.clientWidth, this.nodeAvatar.clientHeight); }
      setView(v) { this.camera.position.set(0, 1.55, 0.85); }
    }

    // --- GLOBAL LOGIC ---
    let avatar, userStream, isModelLoaded = false, areSubtitlesOn = true, interviewConfig = {}, messages = [], speechRecognition, isWaitingForAIResponse = false;
    let finalTranscript = '';

    // Report/Sanitizer
    const EMOJI_CHAR = /[\u{1F300}-\u{1FAFF}\u{2600}-\u{27BF}]/u;
    function extractEmojisAndSanitize(text = "") {
      const chars = Array.from(text), emojis = [];
      const clean = chars.map(ch => EMOJI_CHAR.test(ch) ? (emojis.push(ch), "") : ch).join("").replace(/<<<FINAL_INTERVIEW_REPORT>>>[\s\S]*?<<<END_FINAL_INTERVIEW_REPORT>>>/, "").trim();
      const reportMatch = text.match(/<<<FINAL_INTERVIEW_REPORT>>>([\s\S]*?)<<<END_FINAL_INTERVIEW_REPORT>>>/);
      return { clean, emojis, report: reportMatch ? reportMatch[1] : null };
    }

    const setupScreen = document.getElementById('setup-screen'), loadingScreen = document.getElementById('loading-screen'), permissionsModal = document.getElementById('permissions-modal'), interviewScreen = document.getElementById('interview-screen'), setupForm = document.getElementById('setup-form'), avatarContainer = document.getElementById('avatar-container'), modelLoadingOverlay = document.getElementById('model-loading-overlay'), chatMessages = document.getElementById('chat-messages'), userVideo = document.getElementById('user-video'), subtitlesOverlay = document.getElementById('subtitles-overlay'), currentRoleSpan = document.getElementById('current-role'), loadingProgressBar = document.getElementById('loading-progress-bar'), speechStatus = document.getElementById('speech-status'), subtitlesBtn = document.getElementById('subtitles-btn'), endCallBtn = document.getElementById('end-call-btn'), allowPermissionsBtn = document.getElementById('allow-permissions'), skipPermissionsBtn = document.getElementById('skip-permissions');
    // Hide push to talk - we are always listening
    document.getElementById('push-to-talk-btn').style.display = 'none';

    async function init() {
      setupEventListeners();
      setupContinuousSpeechRecognition();
      loadModelInBackground();
      subtitlesBtn.classList.toggle('active', areSubtitlesOn);
    }

    function setupEventListeners() {
      setupForm.addEventListener('submit', handleSetupSubmit);
      subtitlesBtn.addEventListener('click', toggleSubtitles);
      endCallBtn.addEventListener('click', endInterview);
      if (allowPermissionsBtn) allowPermissionsBtn.addEventListener('click', requestPermissions);
      if (skipPermissionsBtn) skipPermissionsBtn.addEventListener('click', skipPermissions);
      window.addEventListener('resize', () => { if (avatar) avatar.onResize(); });
    }

    // --- CONTINUOUS SPEECH (VAD logic) ---
    function setupContinuousSpeechRecognition() {
      if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        speechRecognition = new SpeechRecognition();
        speechRecognition.continuous = true;
        speechRecognition.interimResults = true;
        speechRecognition.lang = 'en-US';

        speechRecognition.onresult = (event) => {
          let interim = '';
          finalTranscript = ''; // Reset final to accumulation of this session? No, browser handles it.

          // 1. INTERRUPT LOGIC
          // If we detect speech and AI is speaking, cut it off.
          if (avatar && avatar.isSpeaking && event.results.length > 0) {
            const latestResult = event.results[event.results.length - 1];
            if (latestResult[0].transcript.trim().length > 0) {
              avatar.interrupt();
              updateSpeechStatus("Interruption detected...", true);
              // Add marker to history
              if (messages.length && messages[messages.length - 1].role === 'assistant') {
                messages[messages.length - 1].content += " [Interrupted]";
              }
            }
          }

          for (let i = event.resultIndex; i < event.results.length; ++i) {
            if (event.results[i].isFinal) {
              const spoken = event.results[i][0].transcript.trim();
              if (spoken) handleSpeechInput(spoken);
            } else {
              interim += event.results[i][0].transcript;
            }
          }
          if (interim) updateSpeechStatus(`Listening: ${interim}`, true);
        };

        speechRecognition.onend = () => {
          // Restart automatically (Continuous listening)
          if (interviewScreen.classList.contains('hidden') === false) {
            try { speechRecognition.start(); } catch (e) { }
          }
        };

        // Start initially silently
      }
    }

    function handleSpeechInput(text) {
      if (!text.trim() || isWaitingForAIResponse) return;

      // Filter short noise (optional, but requested)
      const words = text.split(' ');
      if (words.length < 2 && !['stop', 'wait', 'no', 'yes'].includes(text.toLowerCase().replace(/[^\w]/g, ''))) {
        return; // Ignore coughs or short noise
      }

      addChatMessage('user', 'You', text);
      sendToAI(text);
    }

    function updateSpeechStatus(t, v) { speechStatus.textContent = t; speechStatus.classList.toggle('visible', v); }

    // --- LOADING ---
    async function loadModelInBackground() {
      try {
        avatar = new TalkingHead(avatarContainer, { ttsEndpoint: TTS_ENDPOINT, cameraView: 'head' });
        await avatar.init();
        updateLoadingProgress(30, 'Loading 3D model...');
        await avatar.showAvatar({ url: AVATAR_URL });
        updateLoadingProgress(100, 'Ready!');
        isModelLoaded = true;
        modelLoadingOverlay.classList.add('hidden');
        loadingScreen.classList.add('hidden');
      } catch (error) { console.error(error); updateLoadingProgress(0, 'Failed to load.'); }
    }
    function updateLoadingProgress(p, t) { loadingProgressBar.style.width = `${p}%`; const lt = document.querySelector('.loading-text'); if (lt) lt.textContent = t; }

    async function handleSetupSubmit(e) {
      e.preventDefault();
      interviewConfig = { specialization: document.getElementById('specialization').value, experienceLevel: document.getElementById('experience-level').value, companyType: document.getElementById('company-type').value, duration: document.getElementById('interview-duration').value };
      currentRoleSpan.textContent = interviewConfig.specialization;
      setupScreen.classList.add('hidden');
      if (!isModelLoaded) { loadingScreen.classList.remove('hidden'); while (!isModelLoaded) await new Promise(r => setTimeout(r, 100)); loadingScreen.classList.add('hidden'); }
      try { await navigator.mediaDevices.getUserMedia({ audio: true }); skipPermissions(); } catch (error) { permissionsModal.classList.remove('hidden'); }
    }
    function skipPermissions() { permissionsModal.classList.add('hidden'); startInterview(); }
    async function requestPermissions() { try { await navigator.mediaDevices.getUserMedia({ audio: true }); skipPermissions(); } catch (e) { skipPermissions(); } }

    async function startInterview() {
      interviewScreen.classList.remove('hidden');
      messages = []; isWaitingForAIResponse = false;
      await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: true })
        .then(stream => { userStream = stream; if (userVideo) { userVideo.srcObject = stream; userVideo.play(); } })
        .catch(e => console.log(e));

      setTimeout(() => avatar && avatar.onResize(), 50);
      try { speechRecognition.start(); } catch (e) { } // Start listening

      const welcome = "I'm Alex. Let's not waste time. Tell me about your background.";
      addChatMessage('ai', 'Alex Johnson', welcome);
      if (avatar) avatar.speakText(welcome);
      if (areSubtitlesOn) showSubtitles(`Alex: ${welcome}`);
    }

    function addChatMessage(type, author, content) {
      const el = document.createElement('div');
      el.className = `message ${type}`;
      el.innerHTML = `<div class="message-author">${author}</div><div class="message-content">${content}</div>`;
      chatMessages.appendChild(el); chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    async function sendToAI(message) {
      if (isWaitingForAIResponse) return; isWaitingForAIResponse = true;
      try {
        messages.push({ role: 'user', content: message });
        const response = await fetch(WORKER_URL, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-Specialization': interviewConfig.specialization, 'X-Experience-Level': interviewConfig.experienceLevel, 'X-Company-Type': interviewConfig.companyType, 'X-Duration': interviewConfig.duration }, body: JSON.stringify({ messages }) });
        const data = await response.json();
        if (data.ok && data.response) {
          let aiMessage = data.response;
          const { clean, emojis, report } = extractEmojisAndSanitize(aiMessage);

          if (report) {
            // Render report specially
            addChatMessage('ai', 'System', '<b>Interview Report Generated</b><br><pre style="white-space:pre-wrap; font-size:0.8em">' + report + '</pre>');
            messages.push({ role: 'assistant', content: aiMessage }); // Save full context
          } else {
            messages.push({ role: 'assistant', content: aiMessage });
            addChatMessage('ai', 'Alex Johnson', clean); // Show clean text in chat

            if (avatar && isModelLoaded) {
              emojis.forEach((e, i) => setTimeout(() => avatar.speakEmoji(e), i * 500));
              avatar.speakText(clean);
            }
          }
        }
      } catch (error) { console.error(error); addChatMessage('ai', 'System', 'Connection error.'); } finally { isWaitingForAIResponse = false; }
    }

    // --- SUBTITLES ---
    function showSubtitles(text) { subtitlesOverlay.textContent = text; subtitlesOverlay.classList.remove('hidden'); }
    window.clearAISubtitles = function () {
      if (subtitlesOverlay._sched) subtitlesOverlay._sched.forEach(id => clearTimeout(id));
      subtitlesOverlay._sched = [];
      subtitlesOverlay.classList.add('hidden');
    };
    window.scheduleAISubtitles = function (timepoints, duration, startTime) {
      if (!areSubtitlesOn) return;
      window.clearAISubtitles();

      const now = new Date(); const timeStr = `[${now.getHours()}:${now.getMinutes()}]`;
      let currentLine = "";

      timepoints.forEach((tp, i) => {
        const delay = (tp.time_seconds * 1000);
        subtitlesOverlay._sched.push(setTimeout(() => {
          // Typewriter / Line-by-line effect
          if (currentLine.length > 50 || /[.!?]/.test(tp.word)) {
            // Reset if line too long or sentence ends, but keep last few words for continuity if needed
            if (/[.!?]/.test(tp.word)) currentLine = "";
          }
          currentLine += " " + tp.word;
          showSubtitles(`Alex: ${currentLine.trim()}`);
        }, delay));
      });
      // Hide after audio
      subtitlesOverlay._sched.push(setTimeout(() => subtitlesOverlay.classList.add('hidden'), duration * 1000 + 1000));
    };

    function toggleSubtitles() { areSubtitlesOn = !areSubtitlesOn; subtitlesBtn.classList.toggle('active', areSubtitlesOn); if (!areSubtitlesOn) subtitlesOverlay.classList.add('hidden'); }
    function endInterview() { if (confirm('End interview?')) { if (userStream) userStream.getTracks().forEach(t => t.stop()); if (avatar) avatar.stopSpeaking(); try { speechRecognition.stop(); } catch (e) { } interviewScreen.classList.add('hidden'); setupScreen.classList.remove('hidden'); isModelLoaded = false; location.reload(); } }

    init();
  </script>

  <script defer src='https://static.cloudflareinsights.com/beacon.min.js'
    data-cf-beacon='{"token": "9ecf6f49919940acb2efcc833483cd5f"}'></script><!-- Cloudflare Pages Analytics -->
  <script defer src='https://static.cloudflareinsights.com/beacon.min.js'
    data-cf-beacon='{"token": "9ecf6f49919940acb2efcc833483cd5f"}'></script><!-- Cloudflare Pages Analytics -->
</body>

</html>